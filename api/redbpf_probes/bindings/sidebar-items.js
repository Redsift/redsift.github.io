initSidebarItems({"constant":[["AF_ALG",""],["AF_APPLETALK",""],["AF_ASH",""],["AF_ATMPVC",""],["AF_ATMSVC",""],["AF_AX25",""],["AF_BLUETOOTH",""],["AF_BRIDGE",""],["AF_CAIF",""],["AF_CAN",""],["AF_DECnet",""],["AF_ECONET",""],["AF_IB",""],["AF_IEEE802154",""],["AF_INET",""],["AF_INET6",""],["AF_IPX",""],["AF_IRDA",""],["AF_ISDN",""],["AF_IUCV",""],["AF_KCM",""],["AF_KEY",""],["AF_LLC",""],["AF_LOCAL",""],["AF_MAX",""],["AF_MPLS",""],["AF_NETBEUI",""],["AF_NETLINK",""],["AF_NETROM",""],["AF_NFC",""],["AF_PACKET",""],["AF_PHONET",""],["AF_PPPOX",""],["AF_QIPCRTR",""],["AF_RDS",""],["AF_ROSE",""],["AF_ROUTE",""],["AF_RXRPC",""],["AF_SECURITY",""],["AF_SMC",""],["AF_SNA",""],["AF_TIPC",""],["AF_UNIX",""],["AF_UNSPEC",""],["AF_VSOCK",""],["AF_WANPIPE",""],["AF_X25",""],["AF_XDP",""],["BPF_A",""],["BPF_ABS",""],["BPF_ADD",""],["BPF_ADJ_ROOM_ENCAP_L2_MASK",""],["BPF_ADJ_ROOM_ENCAP_L2_SHIFT",""],["BPF_ALU",""],["BPF_ALU64",""],["BPF_AND",""],["BPF_ANY",""],["BPF_ARSH",""],["BPF_B",""],["BPF_BUILD_ID_SIZE",""],["BPF_CALL",""],["BPF_CALL_ARGS",""],["BPF_COMPLEXITY_LIMIT_INSNS",""],["BPF_DEVCG_ACC_MKNOD",""],["BPF_DEVCG_ACC_READ",""],["BPF_DEVCG_ACC_WRITE",""],["BPF_DEVCG_DEV_BLOCK",""],["BPF_DEVCG_DEV_CHAR",""],["BPF_DIV",""],["BPF_DW",""],["BPF_END",""],["BPF_EXIST",""],["BPF_EXIT",""],["BPF_FIB_LKUP_RET_BLACKHOLE",""],["BPF_FIB_LKUP_RET_FRAG_NEEDED",""],["BPF_FIB_LKUP_RET_FWD_DISABLED",""],["BPF_FIB_LKUP_RET_NOT_FWDED",""],["BPF_FIB_LKUP_RET_NO_NEIGH",""],["BPF_FIB_LKUP_RET_PROHIBIT",""],["BPF_FIB_LKUP_RET_SUCCESS",""],["BPF_FIB_LKUP_RET_UNREACHABLE",""],["BPF_FIB_LKUP_RET_UNSUPP_LWT",""],["BPF_FIB_LOOKUP_DIRECT",""],["BPF_FIB_LOOKUP_OUTPUT",""],["BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG",""],["BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP",""],["BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL",""],["BPF_FROM_BE",""],["BPF_FROM_LE",""],["BPF_FS_MAGIC",""],["BPF_F_ACCESS_MASK",""],["BPF_F_ADJ_ROOM_ENCAP_L3_IPV4",""],["BPF_F_ADJ_ROOM_ENCAP_L3_IPV6",""],["BPF_F_ADJ_ROOM_ENCAP_L4_GRE",""],["BPF_F_ADJ_ROOM_ENCAP_L4_UDP",""],["BPF_F_ADJ_ROOM_FIXED_GSO",""],["BPF_F_ALLOW_MULTI",""],["BPF_F_ALLOW_OVERRIDE",""],["BPF_F_ANY_ALIGNMENT",""],["BPF_F_CLONE",""],["BPF_F_CTXLEN_MASK",""],["BPF_F_CURRENT_CPU",""],["BPF_F_CURRENT_NETNS",""],["BPF_F_DONT_FRAGMENT",""],["BPF_F_FAST_STACK_CMP",""],["BPF_F_HDR_FIELD_MASK",""],["BPF_F_INDEX_MASK",""],["BPF_F_INGRESS",""],["BPF_F_INVALIDATE_HASH",""],["BPF_F_LOCK",""],["BPF_F_MARK_ENFORCE",""],["BPF_F_MARK_MANGLED_0",""],["BPF_F_NO_COMMON_LRU",""],["BPF_F_NO_PREALLOC",""],["BPF_F_NUMA_NODE",""],["BPF_F_PSEUDO_HDR",""],["BPF_F_QUERY_EFFECTIVE",""],["BPF_F_RDONLY",""],["BPF_F_RDONLY_PROG",""],["BPF_F_RECOMPUTE_CSUM",""],["BPF_F_REUSE_STACKID",""],["BPF_F_SEQ_NUMBER",""],["BPF_F_SKIP_FIELD_MASK",""],["BPF_F_STACK_BUILD_ID",""],["BPF_F_STRICT_ALIGNMENT",""],["BPF_F_SYSCTL_BASE_NAME",""],["BPF_F_TEST_RND_HI32",""],["BPF_F_TEST_STATE_FREQ",""],["BPF_F_TUNINFO_IPV6",""],["BPF_F_USER_BUILD_ID",""],["BPF_F_USER_STACK",""],["BPF_F_WRONLY",""],["BPF_F_WRONLY_PROG",""],["BPF_F_ZERO_CSUM_TX",""],["BPF_F_ZERO_SEED",""],["BPF_H",""],["BPF_IMM",""],["BPF_IND",""],["BPF_JA",""],["BPF_JEQ",""],["BPF_JGE",""],["BPF_JGT",""],["BPF_JLE",""],["BPF_JLT",""],["BPF_JMP",""],["BPF_JMP32",""],["BPF_JNE",""],["BPF_JSET",""],["BPF_JSGE",""],["BPF_JSGT",""],["BPF_JSLE",""],["BPF_JSLT",""],["BPF_K",""],["BPF_LD",""],["BPF_LDX",""],["BPF_LEN",""],["BPF_LL_OFF",""],["BPF_LSH",""],["BPF_MAJOR_VERSION",""],["BPF_MAXINSNS",""],["BPF_MEM",""],["BPF_MEMWORDS",""],["BPF_MINOR_VERSION",""],["BPF_MISC",""],["BPF_MOD",""],["BPF_MOV",""],["BPF_MSH",""],["BPF_MUL",""],["BPF_NEG",""],["BPF_NET_OFF",""],["BPF_NOEXIST",""],["BPF_OBJ_NAME_LEN",""],["BPF_OR",""],["BPF_PSEUDO_CALL",""],["BPF_PSEUDO_MAP_FD",""],["BPF_PSEUDO_MAP_VALUE",""],["BPF_REG_0",""],["BPF_REG_1",""],["BPF_REG_10",""],["BPF_REG_2",""],["BPF_REG_3",""],["BPF_REG_4",""],["BPF_REG_5",""],["BPF_REG_6",""],["BPF_REG_7",""],["BPF_REG_8",""],["BPF_REG_9",""],["BPF_RET",""],["BPF_RSH",""],["BPF_SKB_CB_LEN",""],["BPF_SK_STORAGE_GET_F_CREATE",""],["BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB",""],["BPF_SOCK_OPS_ALL_CB_FLAGS",""],["BPF_SOCK_OPS_BASE_RTT",""],["BPF_SOCK_OPS_NEEDS_ECN",""],["BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB",""],["BPF_SOCK_OPS_RETRANS_CB",""],["BPF_SOCK_OPS_RETRANS_CB_FLAG",""],["BPF_SOCK_OPS_RTO_CB",""],["BPF_SOCK_OPS_RTO_CB_FLAG",""],["BPF_SOCK_OPS_RTT_CB",""],["BPF_SOCK_OPS_RTT_CB_FLAG",""],["BPF_SOCK_OPS_RWND_INIT",""],["BPF_SOCK_OPS_STATE_CB",""],["BPF_SOCK_OPS_STATE_CB_FLAG",""],["BPF_SOCK_OPS_TCP_CONNECT_CB",""],["BPF_SOCK_OPS_TCP_LISTEN_CB",""],["BPF_SOCK_OPS_TIMEOUT_INIT",""],["BPF_SOCK_OPS_VOID",""],["BPF_ST",""],["BPF_STX",""],["BPF_SUB",""],["BPF_SYM_ELF_TYPE",""],["BPF_TAG_SIZE",""],["BPF_TAIL_CALL",""],["BPF_TAX",""],["BPF_TCP_CLOSE",""],["BPF_TCP_CLOSE_WAIT",""],["BPF_TCP_CLOSING",""],["BPF_TCP_ESTABLISHED",""],["BPF_TCP_FIN_WAIT1",""],["BPF_TCP_FIN_WAIT2",""],["BPF_TCP_LAST_ACK",""],["BPF_TCP_LISTEN",""],["BPF_TCP_MAX_STATES",""],["BPF_TCP_NEW_SYN_RECV",""],["BPF_TCP_SYN_RECV",""],["BPF_TCP_SYN_SENT",""],["BPF_TCP_TIME_WAIT",""],["BPF_TO_BE",""],["BPF_TO_LE",""],["BPF_TXA",""],["BPF_W",""],["BPF_X",""],["BPF_XADD",""],["BPF_XOR",""],["ETH_ALEN",""],["ETH_DATA_LEN",""],["ETH_FCS_LEN",""],["ETH_FRAME_LEN",""],["ETH_FW_DUMP_DISABLE",""],["ETH_GSTRING_LEN",""],["ETH_HLEN",""],["ETH_MAX_MTU",""],["ETH_MDIO_SUPPORTS_C22",""],["ETH_MDIO_SUPPORTS_C45",""],["ETH_MIN_MTU",""],["ETH_MODULE_SFF_8079",""],["ETH_MODULE_SFF_8079_LEN",""],["ETH_MODULE_SFF_8436",""],["ETH_MODULE_SFF_8436_LEN",""],["ETH_MODULE_SFF_8436_MAX_LEN",""],["ETH_MODULE_SFF_8472",""],["ETH_MODULE_SFF_8472_LEN",""],["ETH_MODULE_SFF_8636",""],["ETH_MODULE_SFF_8636_LEN",""],["ETH_MODULE_SFF_8636_MAX_LEN",""],["ETH_P_1588",""],["ETH_P_8021AD",""],["ETH_P_8021AH",""],["ETH_P_8021Q",""],["ETH_P_80221",""],["ETH_P_802_2",""],["ETH_P_802_3",""],["ETH_P_802_3_MIN",""],["ETH_P_802_EX1",""],["ETH_P_AARP",""],["ETH_P_AF_IUCV",""],["ETH_P_ALL",""],["ETH_P_AOE",""],["ETH_P_ARCNET",""],["ETH_P_ARP",""],["ETH_P_ATALK",""],["ETH_P_ATMFATE",""],["ETH_P_ATMMPOA",""],["ETH_P_AX25",""],["ETH_P_BATMAN",""],["ETH_P_BPQ",""],["ETH_P_CAIF",""],["ETH_P_CAN",""],["ETH_P_CANFD",""],["ETH_P_CONTROL",""],["ETH_P_CUST",""],["ETH_P_DDCMP",""],["ETH_P_DEC",""],["ETH_P_DIAG",""],["ETH_P_DNA_DL",""],["ETH_P_DNA_RC",""],["ETH_P_DNA_RT",""],["ETH_P_DSA",""],["ETH_P_DSA_8021Q",""],["ETH_P_ECONET",""],["ETH_P_EDSA",""],["ETH_P_ERSPAN",""],["ETH_P_ERSPAN2",""],["ETH_P_FCOE",""],["ETH_P_FIP",""],["ETH_P_HDLC",""],["ETH_P_HSR",""],["ETH_P_IBOE",""],["ETH_P_IEEE802154",""],["ETH_P_IEEEPUP",""],["ETH_P_IEEEPUPAT",""],["ETH_P_IFE",""],["ETH_P_IP",""],["ETH_P_IPV6",""],["ETH_P_IPX",""],["ETH_P_IRDA",""],["ETH_P_LAT",""],["ETH_P_LINK_CTL",""],["ETH_P_LLDP",""],["ETH_P_LOCALTALK",""],["ETH_P_LOOP",""],["ETH_P_LOOPBACK",""],["ETH_P_MACSEC",""],["ETH_P_MAP",""],["ETH_P_MOBITEX",""],["ETH_P_MPLS_MC",""],["ETH_P_MPLS_UC",""],["ETH_P_MVRP",""],["ETH_P_NCSI",""],["ETH_P_NSH",""],["ETH_P_PAE",""],["ETH_P_PAUSE",""],["ETH_P_PHONET",""],["ETH_P_PPPTALK",""],["ETH_P_PPP_DISC",""],["ETH_P_PPP_MP",""],["ETH_P_PPP_SES",""],["ETH_P_PREAUTH",""],["ETH_P_PRP",""],["ETH_P_PUP",""],["ETH_P_PUPAT",""],["ETH_P_QINQ1",""],["ETH_P_QINQ2",""],["ETH_P_QINQ3",""],["ETH_P_RARP",""],["ETH_P_SCA",""],["ETH_P_SLOW",""],["ETH_P_SNAP",""],["ETH_P_TDLS",""],["ETH_P_TEB",""],["ETH_P_TIPC",""],["ETH_P_TRAILER",""],["ETH_P_TR_802_2",""],["ETH_P_TSN",""],["ETH_P_WAN_PPP",""],["ETH_P_WCCP",""],["ETH_P_X25",""],["ETH_P_XDSA",""],["ETH_RESET_SHARED_SHIFT",""],["ETH_RSS_HASH_CRC32_BIT",""],["ETH_RSS_HASH_FUNCS_COUNT",""],["ETH_RSS_HASH_NO_CHANGE",""],["ETH_RSS_HASH_TOP_BIT",""],["ETH_RSS_HASH_UNKNOWN",""],["ETH_RSS_HASH_XOR_BIT",""],["ETH_RXFH_CONTEXT_ALLOC",""],["ETH_RXFH_INDIR_NO_CHANGE",""],["ETH_RX_NFC_IP4",""],["ETH_TLEN",""],["ETH_TP_MDI",""],["ETH_TP_MDI_AUTO",""],["ETH_TP_MDI_INVALID",""],["ETH_TP_MDI_X",""],["ETH_ZLEN",""],["IPPROTO_AH",""],["IPPROTO_BEETPH",""],["IPPROTO_COMP",""],["IPPROTO_DCCP",""],["IPPROTO_DSTOPTS",""],["IPPROTO_EGP",""],["IPPROTO_ENCAP",""],["IPPROTO_ESP",""],["IPPROTO_FRAGMENT",""],["IPPROTO_GRE",""],["IPPROTO_HOPOPTS",""],["IPPROTO_ICMP",""],["IPPROTO_ICMPV6",""],["IPPROTO_IDP",""],["IPPROTO_IGMP",""],["IPPROTO_IP",""],["IPPROTO_IPIP",""],["IPPROTO_IPV6",""],["IPPROTO_MAX",""],["IPPROTO_MH",""],["IPPROTO_MPLS",""],["IPPROTO_MTP",""],["IPPROTO_NONE",""],["IPPROTO_PIM",""],["IPPROTO_PUP",""],["IPPROTO_RAW",""],["IPPROTO_ROUTING",""],["IPPROTO_RSVP",""],["IPPROTO_SCTP",""],["IPPROTO_TCP",""],["IPPROTO_TP",""],["IPPROTO_UDP",""],["IPPROTO_UDPLITE",""],["SK_FL_PROTO_MASK",""],["SK_FL_PROTO_SHIFT",""],["SK_FL_TYPE_MASK",""],["SK_FL_TYPE_SHIFT",""],["SOCK_BINDADDR_LOCK",""],["SOCK_BINDPORT_LOCK",""],["SOCK_CLOEXEC",""],["SOCK_DESTROY_TIME",""],["SOCK_IOC_TYPE",""],["SOCK_NONBLOCK",""],["SOCK_NOSPACE",""],["SOCK_PASSCRED",""],["SOCK_PASSSEC",""],["SOCK_RCVBUF_LOCK",""],["SOCK_SNDBUF_LOCK",""],["SOCK_TYPE_MASK",""],["SOCK_WAKE_IO",""],["SOCK_WAKE_SPACE",""],["SOCK_WAKE_URG",""],["SOCK_WAKE_WAITD",""],["__MAX_BPF_REG",""],["blk_zoned_model_BLK_ZONED_HA",""],["blk_zoned_model_BLK_ZONED_HM",""],["blk_zoned_model_BLK_ZONED_NONE",""],["bpf_access_type_BPF_READ",""],["bpf_access_type_BPF_WRITE",""],["bpf_adj_room_mode_BPF_ADJ_ROOM_MAC",""],["bpf_adj_room_mode_BPF_ADJ_ROOM_NET",""],["bpf_arg_type_ARG_ANYTHING",""],["bpf_arg_type_ARG_CONST_MAP_PTR",""],["bpf_arg_type_ARG_CONST_SIZE",""],["bpf_arg_type_ARG_CONST_SIZE_OR_ZERO",""],["bpf_arg_type_ARG_DONTCARE",""],["bpf_arg_type_ARG_PTR_TO_CTX",""],["bpf_arg_type_ARG_PTR_TO_INT",""],["bpf_arg_type_ARG_PTR_TO_LONG",""],["bpf_arg_type_ARG_PTR_TO_MAP_KEY",""],["bpf_arg_type_ARG_PTR_TO_MAP_VALUE",""],["bpf_arg_type_ARG_PTR_TO_MAP_VALUE_OR_NULL",""],["bpf_arg_type_ARG_PTR_TO_MEM",""],["bpf_arg_type_ARG_PTR_TO_MEM_OR_NULL",""],["bpf_arg_type_ARG_PTR_TO_SOCKET",""],["bpf_arg_type_ARG_PTR_TO_SOCK_COMMON",""],["bpf_arg_type_ARG_PTR_TO_SPIN_LOCK",""],["bpf_arg_type_ARG_PTR_TO_UNINIT_MAP_VALUE",""],["bpf_arg_type_ARG_PTR_TO_UNINIT_MEM",""],["bpf_attach_type_BPF_CGROUP_DEVICE",""],["bpf_attach_type_BPF_CGROUP_GETSOCKOPT",""],["bpf_attach_type_BPF_CGROUP_INET4_BIND",""],["bpf_attach_type_BPF_CGROUP_INET4_CONNECT",""],["bpf_attach_type_BPF_CGROUP_INET4_POST_BIND",""],["bpf_attach_type_BPF_CGROUP_INET6_BIND",""],["bpf_attach_type_BPF_CGROUP_INET6_CONNECT",""],["bpf_attach_type_BPF_CGROUP_INET6_POST_BIND",""],["bpf_attach_type_BPF_CGROUP_INET_EGRESS",""],["bpf_attach_type_BPF_CGROUP_INET_INGRESS",""],["bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE",""],["bpf_attach_type_BPF_CGROUP_SETSOCKOPT",""],["bpf_attach_type_BPF_CGROUP_SOCK_OPS",""],["bpf_attach_type_BPF_CGROUP_SYSCTL",""],["bpf_attach_type_BPF_CGROUP_UDP4_RECVMSG",""],["bpf_attach_type_BPF_CGROUP_UDP4_SENDMSG",""],["bpf_attach_type_BPF_CGROUP_UDP6_RECVMSG",""],["bpf_attach_type_BPF_CGROUP_UDP6_SENDMSG",""],["bpf_attach_type_BPF_FLOW_DISSECTOR",""],["bpf_attach_type_BPF_LIRC_MODE2",""],["bpf_attach_type_BPF_SK_MSG_VERDICT",""],["bpf_attach_type_BPF_SK_SKB_STREAM_PARSER",""],["bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT",""],["bpf_attach_type___MAX_BPF_ATTACH_TYPE",""],["bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_PERCPU",""],["bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_SHARED",""],["bpf_cgroup_storage_type___BPF_CGROUP_STORAGE_MAX",""],["bpf_cmd_BPF_BTF_GET_FD_BY_ID",""],["bpf_cmd_BPF_BTF_GET_NEXT_ID",""],["bpf_cmd_BPF_BTF_LOAD",""],["bpf_cmd_BPF_MAP_CREATE",""],["bpf_cmd_BPF_MAP_DELETE_ELEM",""],["bpf_cmd_BPF_MAP_FREEZE",""],["bpf_cmd_BPF_MAP_GET_FD_BY_ID",""],["bpf_cmd_BPF_MAP_GET_NEXT_ID",""],["bpf_cmd_BPF_MAP_GET_NEXT_KEY",""],["bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_ELEM",""],["bpf_cmd_BPF_MAP_LOOKUP_ELEM",""],["bpf_cmd_BPF_MAP_UPDATE_ELEM",""],["bpf_cmd_BPF_OBJ_GET",""],["bpf_cmd_BPF_OBJ_GET_INFO_BY_FD",""],["bpf_cmd_BPF_OBJ_PIN",""],["bpf_cmd_BPF_PROG_ATTACH",""],["bpf_cmd_BPF_PROG_DETACH",""],["bpf_cmd_BPF_PROG_GET_FD_BY_ID",""],["bpf_cmd_BPF_PROG_GET_NEXT_ID",""],["bpf_cmd_BPF_PROG_LOAD",""],["bpf_cmd_BPF_PROG_QUERY",""],["bpf_cmd_BPF_PROG_TEST_RUN",""],["bpf_cmd_BPF_RAW_TRACEPOINT_OPEN",""],["bpf_cmd_BPF_TASK_FD_QUERY",""],["bpf_func_id_BPF_FUNC_bind",""],["bpf_func_id_BPF_FUNC_clone_redirect",""],["bpf_func_id_BPF_FUNC_csum_diff",""],["bpf_func_id_BPF_FUNC_csum_update",""],["bpf_func_id_BPF_FUNC_current_task_under_cgroup",""],["bpf_func_id_BPF_FUNC_fib_lookup",""],["bpf_func_id_BPF_FUNC_get_cgroup_classid",""],["bpf_func_id_BPF_FUNC_get_current_cgroup_id",""],["bpf_func_id_BPF_FUNC_get_current_comm",""],["bpf_func_id_BPF_FUNC_get_current_pid_tgid",""],["bpf_func_id_BPF_FUNC_get_current_task",""],["bpf_func_id_BPF_FUNC_get_current_uid_gid",""],["bpf_func_id_BPF_FUNC_get_hash_recalc",""],["bpf_func_id_BPF_FUNC_get_listener_sock",""],["bpf_func_id_BPF_FUNC_get_local_storage",""],["bpf_func_id_BPF_FUNC_get_numa_node_id",""],["bpf_func_id_BPF_FUNC_get_prandom_u32",""],["bpf_func_id_BPF_FUNC_get_route_realm",""],["bpf_func_id_BPF_FUNC_get_smp_processor_id",""],["bpf_func_id_BPF_FUNC_get_socket_cookie",""],["bpf_func_id_BPF_FUNC_get_socket_uid",""],["bpf_func_id_BPF_FUNC_get_stack",""],["bpf_func_id_BPF_FUNC_get_stackid",""],["bpf_func_id_BPF_FUNC_getsockopt",""],["bpf_func_id_BPF_FUNC_ktime_get_ns",""],["bpf_func_id_BPF_FUNC_l3_csum_replace",""],["bpf_func_id_BPF_FUNC_l4_csum_replace",""],["bpf_func_id_BPF_FUNC_lwt_push_encap",""],["bpf_func_id_BPF_FUNC_lwt_seg6_action",""],["bpf_func_id_BPF_FUNC_lwt_seg6_adjust_srh",""],["bpf_func_id_BPF_FUNC_lwt_seg6_store_bytes",""],["bpf_func_id_BPF_FUNC_map_delete_elem",""],["bpf_func_id_BPF_FUNC_map_lookup_elem",""],["bpf_func_id_BPF_FUNC_map_peek_elem",""],["bpf_func_id_BPF_FUNC_map_pop_elem",""],["bpf_func_id_BPF_FUNC_map_push_elem",""],["bpf_func_id_BPF_FUNC_map_update_elem",""],["bpf_func_id_BPF_FUNC_msg_apply_bytes",""],["bpf_func_id_BPF_FUNC_msg_cork_bytes",""],["bpf_func_id_BPF_FUNC_msg_pop_data",""],["bpf_func_id_BPF_FUNC_msg_pull_data",""],["bpf_func_id_BPF_FUNC_msg_push_data",""],["bpf_func_id_BPF_FUNC_msg_redirect_hash",""],["bpf_func_id_BPF_FUNC_msg_redirect_map",""],["bpf_func_id_BPF_FUNC_override_return",""],["bpf_func_id_BPF_FUNC_perf_event_output",""],["bpf_func_id_BPF_FUNC_perf_event_read",""],["bpf_func_id_BPF_FUNC_perf_event_read_value",""],["bpf_func_id_BPF_FUNC_perf_prog_read_value",""],["bpf_func_id_BPF_FUNC_probe_read",""],["bpf_func_id_BPF_FUNC_probe_read_str",""],["bpf_func_id_BPF_FUNC_probe_write_user",""],["bpf_func_id_BPF_FUNC_rc_keydown",""],["bpf_func_id_BPF_FUNC_rc_pointer_rel",""],["bpf_func_id_BPF_FUNC_rc_repeat",""],["bpf_func_id_BPF_FUNC_redirect",""],["bpf_func_id_BPF_FUNC_redirect_map",""],["bpf_func_id_BPF_FUNC_send_signal",""],["bpf_func_id_BPF_FUNC_set_hash",""],["bpf_func_id_BPF_FUNC_set_hash_invalid",""],["bpf_func_id_BPF_FUNC_setsockopt",""],["bpf_func_id_BPF_FUNC_sk_fullsock",""],["bpf_func_id_BPF_FUNC_sk_lookup_tcp",""],["bpf_func_id_BPF_FUNC_sk_lookup_udp",""],["bpf_func_id_BPF_FUNC_sk_redirect_hash",""],["bpf_func_id_BPF_FUNC_sk_redirect_map",""],["bpf_func_id_BPF_FUNC_sk_release",""],["bpf_func_id_BPF_FUNC_sk_select_reuseport",""],["bpf_func_id_BPF_FUNC_sk_storage_delete",""],["bpf_func_id_BPF_FUNC_sk_storage_get",""],["bpf_func_id_BPF_FUNC_skb_adjust_room",""],["bpf_func_id_BPF_FUNC_skb_ancestor_cgroup_id",""],["bpf_func_id_BPF_FUNC_skb_cgroup_id",""],["bpf_func_id_BPF_FUNC_skb_change_head",""],["bpf_func_id_BPF_FUNC_skb_change_proto",""],["bpf_func_id_BPF_FUNC_skb_change_tail",""],["bpf_func_id_BPF_FUNC_skb_change_type",""],["bpf_func_id_BPF_FUNC_skb_ecn_set_ce",""],["bpf_func_id_BPF_FUNC_skb_get_tunnel_key",""],["bpf_func_id_BPF_FUNC_skb_get_tunnel_opt",""],["bpf_func_id_BPF_FUNC_skb_get_xfrm_state",""],["bpf_func_id_BPF_FUNC_skb_load_bytes",""],["bpf_func_id_BPF_FUNC_skb_load_bytes_relative",""],["bpf_func_id_BPF_FUNC_skb_pull_data",""],["bpf_func_id_BPF_FUNC_skb_set_tunnel_key",""],["bpf_func_id_BPF_FUNC_skb_set_tunnel_opt",""],["bpf_func_id_BPF_FUNC_skb_store_bytes",""],["bpf_func_id_BPF_FUNC_skb_under_cgroup",""],["bpf_func_id_BPF_FUNC_skb_vlan_pop",""],["bpf_func_id_BPF_FUNC_skb_vlan_push",""],["bpf_func_id_BPF_FUNC_skc_lookup_tcp",""],["bpf_func_id_BPF_FUNC_sock_hash_update",""],["bpf_func_id_BPF_FUNC_sock_map_update",""],["bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set",""],["bpf_func_id_BPF_FUNC_spin_lock",""],["bpf_func_id_BPF_FUNC_spin_unlock",""],["bpf_func_id_BPF_FUNC_strtol",""],["bpf_func_id_BPF_FUNC_strtoul",""],["bpf_func_id_BPF_FUNC_sysctl_get_current_value",""],["bpf_func_id_BPF_FUNC_sysctl_get_name",""],["bpf_func_id_BPF_FUNC_sysctl_get_new_value",""],["bpf_func_id_BPF_FUNC_sysctl_set_new_value",""],["bpf_func_id_BPF_FUNC_tail_call",""],["bpf_func_id_BPF_FUNC_tcp_check_syncookie",""],["bpf_func_id_BPF_FUNC_tcp_gen_syncookie",""],["bpf_func_id_BPF_FUNC_tcp_sock",""],["bpf_func_id_BPF_FUNC_trace_printk",""],["bpf_func_id_BPF_FUNC_unspec",""],["bpf_func_id_BPF_FUNC_xdp_adjust_head",""],["bpf_func_id_BPF_FUNC_xdp_adjust_meta",""],["bpf_func_id_BPF_FUNC_xdp_adjust_tail",""],["bpf_func_id___BPF_FUNC_MAX_ID",""],["bpf_hdr_start_off_BPF_HDR_START_MAC",""],["bpf_hdr_start_off_BPF_HDR_START_NET",""],["bpf_lwt_encap_mode_BPF_LWT_ENCAP_IP",""],["bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6",""],["bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6_INLINE",""],["bpf_map_type_BPF_MAP_TYPE_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS",""],["bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE",""],["bpf_map_type_BPF_MAP_TYPE_CPUMAP",""],["bpf_map_type_BPF_MAP_TYPE_DEVMAP",""],["bpf_map_type_BPF_MAP_TYPE_DEVMAP_HASH",""],["bpf_map_type_BPF_MAP_TYPE_HASH",""],["bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS",""],["bpf_map_type_BPF_MAP_TYPE_LPM_TRIE",""],["bpf_map_type_BPF_MAP_TYPE_LRU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE",""],["bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_QUEUE",""],["bpf_map_type_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY",""],["bpf_map_type_BPF_MAP_TYPE_SK_STORAGE",""],["bpf_map_type_BPF_MAP_TYPE_SOCKHASH",""],["bpf_map_type_BPF_MAP_TYPE_SOCKMAP",""],["bpf_map_type_BPF_MAP_TYPE_STACK",""],["bpf_map_type_BPF_MAP_TYPE_STACK_TRACE",""],["bpf_map_type_BPF_MAP_TYPE_UNSPEC",""],["bpf_map_type_BPF_MAP_TYPE_XSKMAP",""],["bpf_netdev_command_BPF_OFFLOAD_MAP_ALLOC",""],["bpf_netdev_command_BPF_OFFLOAD_MAP_FREE",""],["bpf_netdev_command_XDP_QUERY_PROG",""],["bpf_netdev_command_XDP_QUERY_PROG_HW",""],["bpf_netdev_command_XDP_SETUP_PROG",""],["bpf_netdev_command_XDP_SETUP_PROG_HW",""],["bpf_netdev_command_XDP_SETUP_XSK_UMEM",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCKOPT",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK_ADDR",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SYSCTL",""],["bpf_prog_type_BPF_PROG_TYPE_FLOW_DISSECTOR",""],["bpf_prog_type_BPF_PROG_TYPE_KPROBE",""],["bpf_prog_type_BPF_PROG_TYPE_LIRC_MODE2",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_IN",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_OUT",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_SEG6LOCAL",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT",""],["bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT",""],["bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT",""],["bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE",""],["bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT",""],["bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS",""],["bpf_prog_type_BPF_PROG_TYPE_SK_MSG",""],["bpf_prog_type_BPF_PROG_TYPE_SK_REUSEPORT",""],["bpf_prog_type_BPF_PROG_TYPE_SK_SKB",""],["bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER",""],["bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS",""],["bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT",""],["bpf_prog_type_BPF_PROG_TYPE_UNSPEC",""],["bpf_prog_type_BPF_PROG_TYPE_XDP",""],["bpf_reg_type_CONST_PTR_TO_MAP",""],["bpf_reg_type_NOT_INIT",""],["bpf_reg_type_PTR_TO_CTX",""],["bpf_reg_type_PTR_TO_FLOW_KEYS",""],["bpf_reg_type_PTR_TO_MAP_VALUE",""],["bpf_reg_type_PTR_TO_MAP_VALUE_OR_NULL",""],["bpf_reg_type_PTR_TO_PACKET",""],["bpf_reg_type_PTR_TO_PACKET_END",""],["bpf_reg_type_PTR_TO_PACKET_META",""],["bpf_reg_type_PTR_TO_SOCKET",""],["bpf_reg_type_PTR_TO_SOCKET_OR_NULL",""],["bpf_reg_type_PTR_TO_SOCK_COMMON",""],["bpf_reg_type_PTR_TO_SOCK_COMMON_OR_NULL",""],["bpf_reg_type_PTR_TO_STACK",""],["bpf_reg_type_PTR_TO_TCP_SOCK",""],["bpf_reg_type_PTR_TO_TCP_SOCK_OR_NULL",""],["bpf_reg_type_PTR_TO_TP_BUFFER",""],["bpf_reg_type_PTR_TO_XDP_SOCK",""],["bpf_reg_type_SCALAR_VALUE",""],["bpf_ret_code_BPF_DROP",""],["bpf_ret_code_BPF_LWT_REROUTE",""],["bpf_ret_code_BPF_OK",""],["bpf_ret_code_BPF_REDIRECT",""],["bpf_return_type_RET_INTEGER",""],["bpf_return_type_RET_PTR_TO_MAP_VALUE",""],["bpf_return_type_RET_PTR_TO_MAP_VALUE_OR_NULL",""],["bpf_return_type_RET_PTR_TO_SOCKET_OR_NULL",""],["bpf_return_type_RET_PTR_TO_SOCK_COMMON_OR_NULL",""],["bpf_return_type_RET_PTR_TO_TCP_SOCK_OR_NULL",""],["bpf_return_type_RET_VOID",""],["bpf_stack_build_id_status_BPF_STACK_BUILD_ID_EMPTY",""],["bpf_stack_build_id_status_BPF_STACK_BUILD_ID_IP",""],["bpf_stack_build_id_status_BPF_STACK_BUILD_ID_VALID",""],["bpf_task_fd_type_BPF_FD_TYPE_KPROBE",""],["bpf_task_fd_type_BPF_FD_TYPE_KRETPROBE",""],["bpf_task_fd_type_BPF_FD_TYPE_RAW_TRACEPOINT",""],["bpf_task_fd_type_BPF_FD_TYPE_TRACEPOINT",""],["bpf_task_fd_type_BPF_FD_TYPE_UPROBE",""],["bpf_task_fd_type_BPF_FD_TYPE_URETPROBE",""],["dl_dev_state_DL_DEV_DRIVER_BOUND",""],["dl_dev_state_DL_DEV_NO_DRIVER",""],["dl_dev_state_DL_DEV_PROBING",""],["dl_dev_state_DL_DEV_UNBINDING",""],["dma_data_direction_DMA_BIDIRECTIONAL",""],["dma_data_direction_DMA_FROM_DEVICE",""],["dma_data_direction_DMA_NONE",""],["dma_data_direction_DMA_TO_DEVICE",""],["elv_merge_ELEVATOR_BACK_MERGE",""],["elv_merge_ELEVATOR_DISCARD_MERGE",""],["elv_merge_ELEVATOR_FRONT_MERGE",""],["elv_merge_ELEVATOR_NO_MERGE",""],["ethtool_phys_id_state_ETHTOOL_ID_ACTIVE",""],["ethtool_phys_id_state_ETHTOOL_ID_INACTIVE",""],["ethtool_phys_id_state_ETHTOOL_ID_OFF",""],["ethtool_phys_id_state_ETHTOOL_ID_ON",""],["hrtimer_restart_HRTIMER_NORESTART",""],["hrtimer_restart_HRTIMER_RESTART",""],["kobj_ns_type_KOBJ_NS_TYPES",""],["kobj_ns_type_KOBJ_NS_TYPE_NET",""],["kobj_ns_type_KOBJ_NS_TYPE_NONE",""],["memcg_kmem_state_KMEM_ALLOCATED",""],["memcg_kmem_state_KMEM_NONE",""],["memcg_kmem_state_KMEM_ONLINE",""],["memory_type_MEMORY_DEVICE_DEVDAX",""],["memory_type_MEMORY_DEVICE_FS_DAX",""],["memory_type_MEMORY_DEVICE_PCI_P2PDMA",""],["memory_type_MEMORY_DEVICE_PRIVATE",""],["migrate_mode_MIGRATE_ASYNC",""],["migrate_mode_MIGRATE_SYNC",""],["migrate_mode_MIGRATE_SYNC_LIGHT",""],["migrate_mode_MIGRATE_SYNC_NO_COPY",""],["module_state_MODULE_STATE_COMING",""],["module_state_MODULE_STATE_GOING",""],["module_state_MODULE_STATE_LIVE",""],["module_state_MODULE_STATE_UNFORMED",""],["mq_rq_state_MQ_RQ_COMPLETE",""],["mq_rq_state_MQ_RQ_IDLE",""],["mq_rq_state_MQ_RQ_IN_FLIGHT",""],["net_device_NETREG_DUMMY",""],["net_device_NETREG_REGISTERED",""],["net_device_NETREG_RELEASED",""],["net_device_NETREG_UNINITIALIZED",""],["net_device_NETREG_UNREGISTERED",""],["net_device_NETREG_UNREGISTERING",""],["net_device_RTNL_LINK_INITIALIZED",""],["net_device_RTNL_LINK_INITIALIZING",""],["netdev_tx_NETDEV_TX_BUSY",""],["netdev_tx_NETDEV_TX_OK",""],["netdev_tx___NETDEV_TX_MIN",""],["page_entry_size_PE_SIZE_PMD",""],["page_entry_size_PE_SIZE_PTE",""],["page_entry_size_PE_SIZE_PUD",""],["pid_type_PIDTYPE_MAX",""],["pid_type_PIDTYPE_PGID",""],["pid_type_PIDTYPE_PID",""],["pid_type_PIDTYPE_SID",""],["pid_type_PIDTYPE_TGID",""],["probe_type_PROBE_DEFAULT_STRATEGY",""],["probe_type_PROBE_FORCE_SYNCHRONOUS",""],["probe_type_PROBE_PREFER_ASYNCHRONOUS",""],["quota_type_GRPQUOTA",""],["quota_type_PRJQUOTA",""],["quota_type_USRQUOTA",""],["rpm_request_RPM_REQ_AUTOSUSPEND",""],["rpm_request_RPM_REQ_IDLE",""],["rpm_request_RPM_REQ_NONE",""],["rpm_request_RPM_REQ_RESUME",""],["rpm_request_RPM_REQ_SUSPEND",""],["rpm_status_RPM_ACTIVE",""],["rpm_status_RPM_RESUMING",""],["rpm_status_RPM_SUSPENDED",""],["rpm_status_RPM_SUSPENDING",""],["rw_hint_WRITE_LIFE_EXTREME",""],["rw_hint_WRITE_LIFE_LONG",""],["rw_hint_WRITE_LIFE_MEDIUM",""],["rw_hint_WRITE_LIFE_NONE",""],["rw_hint_WRITE_LIFE_NOT_SET",""],["rw_hint_WRITE_LIFE_SHORT",""],["rx_handler_result_RX_HANDLER_ANOTHER",""],["rx_handler_result_RX_HANDLER_CONSUMED",""],["rx_handler_result_RX_HANDLER_EXACT",""],["rx_handler_result_RX_HANDLER_PASS",""],["sk_action_SK_DROP",""],["sk_action_SK_PASS",""],["sk_pacing_SK_PACING_FQ",""],["sk_pacing_SK_PACING_NEEDED",""],["sk_pacing_SK_PACING_NONE",""],["socket_state_SS_CONNECTED",""],["socket_state_SS_CONNECTING",""],["socket_state_SS_DISCONNECTING",""],["socket_state_SS_FREE",""],["socket_state_SS_UNCONNECTED",""],["tc_setup_type_TC_SETUP_BLOCK",""],["tc_setup_type_TC_SETUP_CLSBPF",""],["tc_setup_type_TC_SETUP_CLSFLOWER",""],["tc_setup_type_TC_SETUP_CLSMATCHALL",""],["tc_setup_type_TC_SETUP_CLSU32",""],["tc_setup_type_TC_SETUP_QDISC_CBS",""],["tc_setup_type_TC_SETUP_QDISC_ETF",""],["tc_setup_type_TC_SETUP_QDISC_GRED",""],["tc_setup_type_TC_SETUP_QDISC_MQ",""],["tc_setup_type_TC_SETUP_QDISC_MQPRIO",""],["tc_setup_type_TC_SETUP_QDISC_PRIO",""],["tc_setup_type_TC_SETUP_QDISC_RED",""],["tc_setup_type_TC_SETUP_QDISC_TAPRIO",""],["tc_setup_type_TC_SETUP_ROOT_QDISC",""],["timespec_type_TT_COMPAT",""],["timespec_type_TT_NATIVE",""],["timespec_type_TT_NONE",""],["uprobe_task_state_UTASK_RUNNING",""],["uprobe_task_state_UTASK_SSTEP",""],["uprobe_task_state_UTASK_SSTEP_ACK",""],["uprobe_task_state_UTASK_SSTEP_TRAPPED",""],["wb_reason_WB_REASON_BACKGROUND",""],["wb_reason_WB_REASON_FOREIGN_FLUSH",""],["wb_reason_WB_REASON_FORKER_THREAD",""],["wb_reason_WB_REASON_FREE_MORE_MEM",""],["wb_reason_WB_REASON_FS_FREE_SPACE",""],["wb_reason_WB_REASON_LAPTOP_TIMER",""],["wb_reason_WB_REASON_MAX",""],["wb_reason_WB_REASON_PERIODIC",""],["wb_reason_WB_REASON_SYNC",""],["wb_reason_WB_REASON_VMSCAN",""],["writeback_sync_modes_WB_SYNC_ALL",""],["writeback_sync_modes_WB_SYNC_NONE",""],["xdp_action_XDP_ABORTED",""],["xdp_action_XDP_DROP",""],["xdp_action_XDP_PASS",""],["xdp_action_XDP_REDIRECT",""],["xdp_action_XDP_TX",""],["zone_type_ZONE_DEVICE",""],["zone_type_ZONE_DMA",""],["zone_type_ZONE_DMA32",""],["zone_type_ZONE_MOVABLE",""],["zone_type_ZONE_NORMAL",""],["zone_type___MAX_NR_ZONES",""]],"struct":[["Qdisc",""],["Qdisc_class_ops",""],["Qdisc_ops",""],["__BindgenBitfieldUnit",""],["__BindgenUnionField",""],["__IncompleteArrayField",""],["__call_single_data",""],["__kernel_timespec",""],["__sifields__bindgen_ty_1",""],["__sifields__bindgen_ty_2",""],["__sifields__bindgen_ty_3",""],["__sifields__bindgen_ty_4",""],["__sifields__bindgen_ty_5",""],["__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1",""],["__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2",""],["__sifields__bindgen_ty_6",""],["__sifields__bindgen_ty_7",""],["__sk_buff",""],["acpi_device_id",""],["address_space","struct address_space - Contents of a cacheable, mappable object. @host: Owner, either the inode or the block_device. @i_pages: Cached pages. @gfp_mask: Memory allocation flags to use for allocating pages. @i_mmap_writable: Number of VM_SHARED mappings. @nr_thps: Number of THPs in the pagecache (non-shmem only). @i_mmap: Tree of private and shared mappings. @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable. @nrpages: Number of page entries, protected by the i_pages lock. @nrexceptional: Shadow or DAX entries, protected by the i_pages lock. @writeback_index: Writeback starts here. @a_ops: Methods. @flags: Error bits and flags (AS_*). @wb_err: The most recent error which has occurred. @private_lock: For use by the owner of the address_space. @private_list: For use by the owner of the address_space. @private_data: For use by the owner of the address_space."],["address_space_operations",""],["anon_vma",""],["arch_tlbflush_unmap_batch",""],["arch_uprobe_task",""],["assoc_array",""],["assoc_array_ptr",""],["atomic64_t",""],["atomic_t",""],["attribute",""],["attribute_group","struct attribute_group - data structure used to declare an attribute group. @name:\tOptional: Attribute group name If specified, the attribute group will be created in a new subdirectory with this name. @is_visible:\tOptional: Function to return permissions associated with an attribute of the group. Will be called repeatedly for each non-binary attribute in the group. Only read/write permissions as well as SYSFS_PREALLOC are accepted. Must return 0 if an attribute is not visible. The returned value will replace static permissions defined in struct attribute. @is_bin_visible: Optional: Function to return permissions associated with a binary attribute of the group. Will be called repeatedly for each binary attribute in the group. Only read/write permissions as well as SYSFS_PREALLOC are accepted. Must return 0 if a binary attribute is not visible. The returned value will replace static permissions defined in struct bin_attribute. @attrs:\tPointer to NULL terminated list of attributes. @bin_attrs:\tPointer to NULL terminated list of binary attributes. Either attrs or bin_attrs or both must be provided."],["audit_context",""],["autogroup",""],["backing_dev_info",""],["badblocks",""],["bdi_writeback",""],["bdi_writeback_congested",""],["bin_attribute",""],["bio",""],["bio_integrity_payload",""],["bio_issue",""],["bio_list",""],["bio_set",""],["bio_vec",""],["blk_flush_queue",""],["blk_integrity",""],["blk_integrity_iter",""],["blk_integrity_profile",""],["blk_mq_alloc_data",""],["blk_mq_ctx",""],["blk_mq_debugfs_attr",""],["blk_mq_hw_ctx",""],["blk_mq_ops",""],["blk_mq_tag_set",""],["blk_plug",""],["blk_queue_stats",""],["blk_rq_stat",""],["blk_stat_callback",""],["blk_trace",""],["blk_zone","struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl."],["blkcg",""],["blkcg_gq",""],["blkcg_policy_data",""],["blkg_policy_data",""],["blkg_rwstat",""],["block_device",""],["block_device_operations",""],["bpf_array",""],["bpf_array__bindgen_ty_1",""],["bpf_attr__bindgen_ty_1",""],["bpf_attr__bindgen_ty_10",""],["bpf_attr__bindgen_ty_11",""],["bpf_attr__bindgen_ty_12",""],["bpf_attr__bindgen_ty_2",""],["bpf_attr__bindgen_ty_3",""],["bpf_attr__bindgen_ty_4",""],["bpf_attr__bindgen_ty_5",""],["bpf_attr__bindgen_ty_6",""],["bpf_attr__bindgen_ty_7",""],["bpf_attr__bindgen_ty_8",""],["bpf_attr__bindgen_ty_9",""],["bpf_binary_header",""],["bpf_btf_info",""],["bpf_cgroup_dev_ctx",""],["bpf_cgroup_storage",""],["bpf_cgroup_storage_key",""],["bpf_cgroup_storage_map",""],["bpf_context",""],["bpf_cpu_map_entry",""],["bpf_dtab_netdev",""],["bpf_event_entry",""],["bpf_fib_lookup",""],["bpf_flow_dissector",""],["bpf_flow_keys",""],["bpf_flow_keys__bindgen_ty_1__bindgen_ty_1",""],["bpf_flow_keys__bindgen_ty_1__bindgen_ty_2",""],["bpf_func_info",""],["bpf_func_proto",""],["bpf_insn",""],["bpf_insn_access_aux",""],["bpf_line_info",""],["bpf_lpm_trie_key",""],["bpf_map",""],["bpf_map_def",""],["bpf_map_dev_ops",""],["bpf_map_info",""],["bpf_map_memory",""],["bpf_map_ops",""],["bpf_offload_dev",""],["bpf_offloaded_map",""],["bpf_perf_event_data",""],["bpf_perf_event_value",""],["bpf_prog",""],["bpf_prog__bindgen_ty_1",""],["bpf_prog_array",""],["bpf_prog_array_item",""],["bpf_prog_aux",""],["bpf_prog_info",""],["bpf_prog_list",""],["bpf_prog_offload",""],["bpf_prog_offload_ops",""],["bpf_prog_ops",""],["bpf_prog_stats",""],["bpf_raw_event_map",""],["bpf_raw_tracepoint_args",""],["bpf_redirect_info",""],["bpf_sk_storage",""],["bpf_skb_data_end",""],["bpf_sock",""],["bpf_sock_addr",""],["bpf_sock_addr_kern",""],["bpf_sock_ops",""],["bpf_sock_ops_kern",""],["bpf_sock_tuple",""],["bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1",""],["bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2",""],["bpf_sockopt",""],["bpf_sockopt_kern",""],["bpf_spin_lock",""],["bpf_stack_build_id",""],["bpf_storage_buffer",""],["bpf_sysctl",""],["bpf_sysctl_kern",""],["bpf_tcp_sock",""],["bpf_tunnel_key",""],["bpf_verifier_env",""],["bpf_verifier_ops",""],["bpf_xdp_sock",""],["bpf_xfrm_state",""],["bsg_class_device",""],["bsg_ops",""],["btf",""],["btf_type",""],["bucket_table","struct bucket_table - Table of hash buckets @size: Number of hash buckets @nest: Number of bits of first-level nested table. @rehash: Current bucket being rehashed @hash_rnd: Random seed to fold into hash @walkers: List of active walkers @rcu: RCU structure for freeing the table @future_tbl: Table under construction during rehashing @ntbl: Nested table used when out of memory. @buckets: size * hash buckets"],["bug_entry",""],["bus_type","struct bus_type - The bus type of the device"],["bvec_iter",""],["callback_head","struct callback_head - callback structure for use with RCU and task_work @next: next update requests in a list @func: actual update function to call after the grace period."],["can_dev_rcv_lists",""],["can_pkg_stats",""],["can_rcv_lists_stats",""],["capture_control",""],["cdev",""],["cee_pfc","struct cee_pfc - CEE PFC managed object"],["cee_pg","struct cee_pg - CEE Priority-Group managed object"],["cfs_rq",""],["cftype",""],["cgroup",""],["cgroup_base_stat",""],["cgroup_bpf",""],["cgroup_file",""],["cgroup_freezer_state",""],["cgroup_namespace",""],["cgroup_root",""],["cgroup_rstat_cpu",""],["cgroup_subsys",""],["cgroup_subsys_state",""],["cgroup_taskset",""],["cisco_proto",""],["class","struct class - device classes @name:\tName of the class. @owner:\tThe module owner. @class_groups: Default attributes of this class. @dev_groups:\tDefault attributes of the devices that belong to the class. @dev_kobj:\tThe kobject that represents this class and links it into the hierarchy. @dev_uevent:\tCalled when a device is added, removed from this class, or a few other things that generate uevents to add the environment variables. @devnode:\tCallback to provide the devtmpfs. @class_release: Called to release this class. @dev_release: Called to release the device. @shutdown_pre: Called at shut-down time before driver shutdown. @ns_type:\tCallbacks so sysfs can detemine namespaces. @namespace:\tNamespace of the device belongs to this class. @get_ownership: Allows class to specify uid/gid of the sysfs directories for the devices belonging to the class. Usually tied to device's namespace. @pm:\t\tThe default device power management operations of this class. @p:\t\tThe private data of the driver core, no one other than the driver core can touch this."],["compat_robust_list",""],["compat_robust_list_head",""],["completion",""],["core_state",""],["core_thread",""],["cpu_itimer",""],["cpu_rmap",""],["cpumask",""],["cred",""],["css_set",""],["ct_pcpu",""],["ctl_dir",""],["ctl_node",""],["ctl_table",""],["ctl_table_header",""],["ctl_table_header__bindgen_ty_1__bindgen_ty_1",""],["ctl_table_poll",""],["ctl_table_root",""],["ctl_table_set",""],["dcb_app",""],["dcb_peer_app_info","struct dcb_peer_app_info - APP feature information sent by the peer"],["dcbnl_buffer",""],["dcbnl_rtnl_ops",""],["deferred_split",""],["delayed_call",""],["delayed_work",""],["dentry",""],["dentry_operations",""],["desc_struct",""],["dev_archdata",""],["dev_ifalias",""],["dev_links_info","struct dev_links_info - Device data related to device links. @suppliers: List of links to supplier devices. @consumers: List of links to consumer devices. @status: Driver status information."],["dev_pagemap","struct dev_pagemap - metadata for ZONE_DEVICE mappings @altmap: pre-allocated/reserved memory for vmemmap allocations @res: physical address range covered by @ref @ref: reference count that pins the devm_memremap_pages() mapping @internal_ref: internal reference if @ref is not provided by the caller @done: completion for @internal_ref @dev: host device of the mapping for debug @data: private data pointer for page_free() @type: memory type: see MEMORY_* in memory_hotplug.h @flags: PGMAP_* flags to specify defailed behavior @ops: method table"],["dev_pagemap_ops",""],["dev_pin_info",""],["dev_pm_domain","struct dev_pm_domain - power management domain representation."],["dev_pm_info",""],["dev_pm_ops","struct dev_pm_ops - device PM callbacks."],["dev_pm_qos",""],["device","struct device - The basic device structure @parent:\tThe device's \"parent\" device, the device to which it is attached. In most cases, a parent device is some sort of bus or host controller. If parent is NULL, the device, is a top-level device, which is not usually what you want. @p:\t\tHolds the private data of the driver core portions of the device. See the comment of the struct device_private for detail. @kobj:\tA top-level, abstract class from which other classes are derived. @init_name:\tInitial name of the device. @type:\tThe type of device. This identifies the device type and carries type-specific information. @mutex:\tMutex to synchronize calls to its driver. @lockdep_mutex: An optional debug lock that a subsystem can use as a peer lock to gain localized lockdep coverage of the device_lock. @bus:\tType of bus device is on. @driver:\tWhich driver has allocated this @platform_data: Platform data specific to the device. Example: For devices on custom boards, as typical of embedded and SOC based hardware, Linux often uses platform_data to point to board-specific structures describing devices and how they are wired.  That can include what ports are available, chip variants, which GPIO pins act in what additional roles, and so on.  This shrinks the \"Board Support Packages\" (BSPs) and minimizes board-specific #ifdefs in drivers. @driver_data: Private pointer for driver specific info. @links:\tLinks to suppliers and consumers of this device. @power:\tFor device power management. See Documentation/driver-api/pm/devices.rst for details. @pm_domain:\tProvide callbacks that are executed during system suspend, hibernation, system resume and during runtime PM transitions along with subsystem-level and driver-level callbacks. @pins:\tFor device pin management. See Documentation/driver-api/pinctl.rst for details. @msi_list:\tHosts MSI descriptors @msi_domain: The generic MSI domain this device is using. @numa_node:\tNUMA node this device is close to. @dma_ops:    DMA mapping operations for this device. @dma_mask:\tDma mask (if dma'ble device). @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all hardware supports 64-bit addresses for consistent allocations such descriptors. @bus_dma_mask: Mask of an upstream bridge or bus which imposes a smaller DMA limit than the device itself supports. @dma_pfn_offset: offset of DMA memory range relatively of RAM @dma_parms:\tA low level driver may set these to teach IOMMU code about segment limitations. @dma_pools:\tDma pools (if dma'ble device). @dma_mem:\tInternal for coherent mem override. @cma_area:\tContiguous memory area for dma allocations @archdata:\tFor arch-specific additions. @of_node:\tAssociated device tree node. @fwnode:\tAssociated device node supplied by platform firmware. @devt:\tFor creating the sysfs \"dev\". @id:\t\tdevice instance @devres_lock: Spinlock to protect the resource of the device. @devres_head: The resources list of the device. @knode_class: The node used to add the device to the class list. @class:\tThe class of the device. @groups:\tOptional attribute groups. @release:\tCallback to free the device after all references have gone away. This should be set by the allocator of the device (i.e. the bus driver that discovered the device). @iommu_group: IOMMU group the device belongs to. @iommu_fwspec: IOMMU-specific properties supplied by firmware. @iommu_param: Per device generic IOMMU runtime data"],["device_dma_parameters",""],["device_driver","struct device_driver - The basic device driver structure @name:\tName of the device driver. @bus:\tThe bus which the device of this driver belongs to. @owner:\tThe module owner. @mod_name:\tUsed for built-in modules. @suppress_bind_attrs: Disables bind/unbind via sysfs. @probe_type:\tType of the probe (synchronous or asynchronous) to use. @of_match_table: The open firmware table. @acpi_match_table: The ACPI match table. @probe:\tCalled to query the existence of a specific device, whether this driver can work with it, and bind the driver to a specific device. @remove:\tCalled when the device is removed from the system to unbind a device from this driver. @shutdown:\tCalled at shut-down time to quiesce the device. @suspend:\tCalled to put the device to sleep mode. Usually to a low power state. @resume:\tCalled to bring a device from sleep mode. @groups:\tDefault attributes that get created by the driver core automatically. @dev_groups:\tAdditional attributes attached to device instance once the it is bound to the driver. @pm:\t\tPower management operations of the device which matched this driver. @coredump:\tCalled when sysfs entry is written to. The device driver is expected to call the dev_coredump API resulting in a uevent. @p:\t\tDriver core's private data, no one other than the driver core can touch this."],["device_node",""],["device_private",""],["device_type",""],["devlink_port",""],["dir_context",""],["disk_events",""],["disk_part_tbl",""],["disk_stats",""],["dma_map_ops",""],["dn_dev",""],["dql",""],["dquot",""],["dquot_operations",""],["driver_private",""],["dsa_port",""],["dst_entry",""],["dst_ops",""],["ebt_table",""],["elevator_mq_ops",""],["elevator_queue",""],["elevator_type",""],["elf64_hdr",""],["elf64_shdr",""],["elf64_sym",""],["elv_fs_entry",""],["error_injection_entry",""],["ethhdr",""],["ethtool_ah_espip4_spec","struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4 @ip4src: Source host @ip4dst: Destination host @spi: Security parameters index @tos: Type-of-service"],["ethtool_ah_espip6_spec","struct ethtool_ah_espip6_spec - flow specification for IPsec/IPv6 @ip6src: Source host @ip6dst: Destination host @spi: Security parameters index @tclass: Traffic Class"],["ethtool_channels","struct ethtool_channels - configuring number of network channel @cmd: ETHTOOL_{G,S}CHANNELS @max_rx: Read only. Maximum number of receive channel the driver support. @max_tx: Read only. Maximum number of transmit channel the driver support. @max_other: Read only. Maximum number of other channel the driver support. @max_combined: Read only. Maximum number of combined channel the driver support. Set of queues RX, TX or other. @rx_count: Valid values are in the range 1 to the max_rx. @tx_count: Valid values are in the range 1 to the max_tx. @other_count: Valid values are in the range 1 to the max_other. @combined_count: Valid values are in the range 1 to the max_combined."],["ethtool_coalesce","struct ethtool_coalesce - coalescing parameters for IRQs and stats updates @cmd: ETHTOOL_{G,S}COALESCE @rx_coalesce_usecs: How many usecs to delay an RX interrupt after a packet arrives. @rx_max_coalesced_frames: Maximum number of packets to receive before an RX interrupt. @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that this value applies while an IRQ is being serviced by the host. @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames, except that this value applies while an IRQ is being serviced by the host. @tx_coalesce_usecs: How many usecs to delay a TX interrupt after a packet is sent. @tx_max_coalesced_frames: Maximum number of packets to be sent before a TX interrupt. @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that this value applies while an IRQ is being serviced by the host. @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames, except that this value applies while an IRQ is being serviced by the host. @stats_block_coalesce_usecs: How many usecs to delay in-memory statistics block updates.  Some drivers do not have an in-memory statistic block, and in such cases this value is ignored.  This value must not be zero. @use_adaptive_rx_coalesce: Enable adaptive RX coalescing. @use_adaptive_tx_coalesce: Enable adaptive TX coalescing. @pkt_rate_low: Threshold for low packet rate (packets per second). @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after a packet arrives, when the packet rate is below @pkt_rate_low. @rx_max_coalesced_frames_low: Maximum number of packets to be received before an RX interrupt, when the packet rate is below @pkt_rate_low. @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after a packet is sent, when the packet rate is below @pkt_rate_low. @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before a TX interrupt, when the packet rate is below @pkt_rate_low. @pkt_rate_high: Threshold for high packet rate (packets per second). @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after a packet arrives, when the packet rate is above @pkt_rate_high. @rx_max_coalesced_frames_high: Maximum number of packets to be received before an RX interrupt, when the packet rate is above @pkt_rate_high. @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after a packet is sent, when the packet rate is above @pkt_rate_high. @tx_max_coalesced_frames_high: Maximum number of packets to be sent before a TX interrupt, when the packet rate is above @pkt_rate_high. @rate_sample_interval: How often to do adaptive coalescing packet rate sampling, measured in seconds.  Must not be zero."],["ethtool_drvinfo","struct ethtool_drvinfo - general driver and device information @cmd: Command number = %ETHTOOL_GDRVINFO @driver: Driver short name.  This should normally match the name in its bus driver structure (e.g. pci_driver::name).  Must not be an empty string. @version: Driver version string; may be an empty string @fw_version: Firmware version string; may be an empty string @erom_version: Expansion ROM version string; may be an empty string @bus_info: Device bus address.  This should match the dev_name() string for the underlying bus device, if there is one.  May be an empty string. @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS commands; also the number of strings in the %ETH_SS_PRIV_FLAGS set @n_stats: Number of u64 statistics returned by the %ETHTOOL_GSTATS command; also the number of strings in the %ETH_SS_STATS set @testinfo_len: Number of results returned by the %ETHTOOL_TEST command; also the number of strings in the %ETH_SS_TEST set @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM and %ETHTOOL_SEEPROM commands, in bytes @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS command, in bytes"],["ethtool_dump","struct ethtool_dump - used for retrieving, setting device dump @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or %ETHTOOL_SET_DUMP @version: FW version of the dump, filled in by driver @flag: driver dependent flag for dump setting, filled in by driver during get and filled in by ethtool for set operation. flag must be initialized by macro ETH_FW_DUMP_DISABLE value when firmware dump is disabled. @len: length of dump data, used as the length of the user buffer on entry to %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver for %ETHTOOL_GET_DUMP_FLAG command @data: data collected for get dump data operation"],["ethtool_eee","struct ethtool_eee - Energy Efficient Ethernet information @cmd: ETHTOOL_{G,S}EEE @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations for which there is EEE support. @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations advertised as eee capable. @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations advertised by the link partner as eee capable. @eee_active: Result of the eee auto negotiation. @eee_enabled: EEE configured mode (enabled/disabled). @tx_lpi_enabled: Whether the interface should assert its tx lpi, given that eee was negotiated. @tx_lpi_timer: Time in microseconds the interface delays prior to asserting its tx lpi (after reaching 'idle' state). Effective only when eee was negotiated and tx_lpi_enabled was set."],["ethtool_eeprom","struct ethtool_eeprom - EEPROM dump @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or %ETHTOOL_SEEPROM @magic: A 'magic cookie' value to guard against accidental changes. The value passed in to %ETHTOOL_SEEPROM must match the value returned by %ETHTOOL_GEEPROM for the same device.  This is unused when @cmd is %ETHTOOL_GMODULEEEPROM. @offset: Offset within the EEPROM to begin reading/writing, in bytes @len: On entry, number of bytes to read/write.  On successful return, number of bytes actually read/written.  In case of error, this may indicate at what point the error occurred. @data: Buffer to read/write from"],["ethtool_fecparam","struct ethtool_fecparam - Ethernet forward error correction(fec) parameters @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM @active_fec: FEC mode which is active on porte @fec: Bitmask of supported/configured FEC modes @rsvd: Reserved for future extensions. i.e FEC bypass feature."],["ethtool_flash",""],["ethtool_flow_ext","struct ethtool_flow_ext - additional RX flow fields @h_dest: destination MAC address @vlan_etype: VLAN EtherType @vlan_tci: VLAN tag control information @data: user defined data"],["ethtool_link_ksettings",""],["ethtool_link_ksettings__bindgen_ty_1",""],["ethtool_link_settings","struct ethtool_link_settings - link control and status"],["ethtool_modinfo","struct ethtool_modinfo - plugin module eeprom information @cmd: %ETHTOOL_GMODULEINFO @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx @eeprom_len: Length of the eeprom"],["ethtool_ops","struct ethtool_ops - optional netdev operations @get_drvinfo: Report driver/device information.  Should only set the @driver, @version, @fw_version and @bus_info fields.  If not implemented, the @driver and @bus_info fields will be filled in according to the netdev's parent device. @get_regs_len: Get buffer length required for @get_regs @get_regs: Get device registers @get_wol: Report whether Wake-on-Lan is enabled @set_wol: Turn Wake-on-Lan on or off.  Returns a negative error code or zero. @get_msglevel: Report driver message level.  This should be the value of the @msg_enable field used by netif logging functions. @set_msglevel: Set driver message level @nway_reset: Restart autonegotiation.  Returns a negative error code or zero. @get_link: Report whether physical link is up.  Will only be called if the netdev is up.  Should usually be set to ethtool_op_get_link(), which uses netif_carrier_ok(). @get_eeprom: Read data from the device EEPROM. Should fill in the magic field.  Don't need to check len for zero or wraparound.  Fill in the data argument with the eeprom values from offset to offset + len.  Update len to the amount read. Returns an error or zero. @set_eeprom: Write data to the device EEPROM. Should validate the magic field.  Don't need to check len for zero or wraparound.  Update len to the amount written.  Returns an error or zero. @get_coalesce: Get interrupt coalescing parameters.  Returns a negative error code or zero. @set_coalesce: Set interrupt coalescing parameters.  Returns a negative error code or zero. @get_ringparam: Report ring sizes @set_ringparam: Set ring sizes.  Returns a negative error code or zero. @get_pauseparam: Report pause parameters @set_pauseparam: Set pause parameters.  Returns a negative error code or zero. @self_test: Run specified self-tests @get_strings: Return a set of strings that describe the requested objects @set_phys_id: Identify the physical devices, e.g. by flashing an LED attached to it.  The implementation may update the indicator asynchronously or synchronously, but in either case it must return quickly.  It is initially called with the argument %ETHTOOL_ID_ACTIVE, and must either activate asynchronous updates and return zero, return a negative error or return a positive frequency for synchronous indication (e.g. 1 for one on/off cycle per second).  If it returns a frequency then it will be called again at intervals with the argument %ETHTOOL_ID_ON or %ETHTOOL_ID_OFF and should set the state of the indicator accordingly.  Finally, it is called with the argument %ETHTOOL_ID_INACTIVE and must deactivate the indicator.  Returns a negative error code or zero. @get_ethtool_stats: Return extended statistics about the device. This is only useful if the device maintains statistics not included in &struct rtnl_link_stats64. @begin: Function to be called before any other operation.  Returns a negative error code or zero. @complete: Function to be called after any other operation except @begin.  Will be called even if the other operation failed. @get_priv_flags: Report driver-specific feature flags. @set_priv_flags: Set driver-specific feature flags.  Returns a negative error code or zero. @get_sset_count: Get number of strings that @get_strings will write. @get_rxnfc: Get RX flow classification rules.  Returns a negative error code or zero. @set_rxnfc: Set RX flow classification rules.  Returns a negative error code or zero. @flash_device: Write a firmware image to device's flash memory. Returns a negative error code or zero. @reset: Reset (part of) the device, as specified by a bitmask of flags from &enum ethtool_reset_flags.  Returns a negative error code or zero. @get_rxfh_key_size: Get the size of the RX flow hash key. Returns zero if not supported for this specific device. @get_rxfh_indir_size: Get the size of the RX flow hash indirection table. Returns zero if not supported for this specific device. @get_rxfh: Get the contents of the RX flow hash indirection table, hash key and/or hash function. Returns a negative error code or zero. @set_rxfh: Set the contents of the RX flow hash indirection table, hash key, and/or hash function.  Arguments which are set to %NULL or zero will remain unchanged. Returns a negative error code or zero. An error code must be returned if at least one unsupported change was requested. @get_rxfh_context: Get the contents of the RX flow hash indirection table, hash key, and/or hash function assiciated to the given rss context. Returns a negative error code or zero. @set_rxfh_context: Create, remove and configure RSS contexts. Allows setting the contents of the RX flow hash indirection table, hash key, and/or hash function associated to the given context. Arguments which are set to %NULL or zero will remain unchanged. Returns a negative error code or zero. An error code must be returned if at least one unsupported change was requested. @get_channels: Get number of channels. @set_channels: Set number of channels.  Returns a negative error code or zero. @get_dump_flag: Get dump flag indicating current dump length, version, and flag of the device. @get_dump_data: Get dump data. @set_dump: Set dump specific flags to the device. @get_ts_info: Get the time stamping and PTP hardware clock capabilities. Drivers supporting transmit time stamps in software should set this to ethtool_op_get_ts_info(). @get_module_info: Get the size and type of the eeprom contained within a plug-in module. @get_module_eeprom: Get the eeprom information from the plug-in module @get_eee: Get Energy-Efficient (EEE) supported and status. @set_eee: Set EEE status (enable/disable) as well as LPI timers. @get_per_queue_coalesce: Get interrupt coalescing parameters per queue. It must check that the given queue number is valid. If neither a RX nor a TX queue has this number, return -EINVAL. If only a RX queue or a TX queue has this number, set the inapplicable fields to ~0 and return 0. Returns a negative error code or zero. @set_per_queue_coalesce: Set interrupt coalescing parameters per queue. It must check that the given queue number is valid. If neither a RX nor a TX queue has this number, return -EINVAL. If only a RX queue or a TX queue has this number, ignore the inapplicable fields. Returns a negative error code or zero. @get_link_ksettings: Get various device settings including Ethernet link settings. The %cmd and %link_mode_masks_nwords fields should be ignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter), any change to them will be overwritten by kernel. Returns a negative error code or zero. @set_link_ksettings: Set various device settings including Ethernet link settings. The %cmd and %link_mode_masks_nwords fields should be ignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter), any change to them will be overwritten by kernel. Returns a negative error code or zero. @get_fecparam: Get the network device Forward Error Correction parameters. @set_fecparam: Set the network device Forward Error Correction parameters. @get_ethtool_phy_stats: Return extended statistics about the PHY device. This is only useful if the device maintains PHY statistics and cannot use the standard PHY library helpers."],["ethtool_pauseparam","struct ethtool_pauseparam - Ethernet pause (flow control) parameters @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM @autoneg: Flag to enable autonegotiation of pause frame use @rx_pause: Flag to enable reception of pause frames @tx_pause: Flag to enable transmission of pause frames"],["ethtool_regs","struct ethtool_regs - hardware register dump @cmd: Command number = %ETHTOOL_GREGS @version: Dump format version.  This is driver-specific and may distinguish different chips/revisions.  Drivers must use new version numbers whenever the dump format changes in an incompatible way. @len: On entry, the real length of @data.  On return, the number of bytes used. @data: Buffer for the register dump"],["ethtool_ringparam","struct ethtool_ringparam - RX/TX ring parameters @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM @rx_max_pending: Maximum supported number of pending entries per RX ring.  Read-only. @rx_mini_max_pending: Maximum supported number of pending entries per RX mini ring.  Read-only. @rx_jumbo_max_pending: Maximum supported number of pending entries per RX jumbo ring.  Read-only. @tx_max_pending: Maximum supported number of pending entries per TX ring.  Read-only. @rx_pending: Current maximum number of pending entries per RX ring @rx_mini_pending: Current maximum number of pending entries per RX mini ring @rx_jumbo_pending: Current maximum number of pending entries per RX jumbo ring @tx_pending: Current maximum supported number of pending entries per TX ring"],["ethtool_rx_flow_spec","struct ethtool_rx_flow_spec - classification rule for RX flows @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW @h_u: Flow fields to match (dependent on @flow_type) @h_ext: Additional fields to match @m_u: Masks for flow field bits to be matched @m_ext: Masks for additional field bits to be matched Note, all additional fields must be ignored unless @flow_type includes the %FLOW_EXT or %FLOW_MAC_EXT flag (see &struct ethtool_flow_ext description). @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC if packets should be discarded, or %RX_CLS_FLOW_WAKE if the packets should be used for Wake-on-LAN with %WAKE_FILTER @location: Location of rule in the table.  Locations must be numbered such that a flow matching multiple rules will be classified according to the first (lowest numbered) rule."],["ethtool_rxnfc","struct ethtool_rxnfc - command to get or set RX flow classification rules @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH, %ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE, %ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW @data: Command-dependent value @fs: Flow classification rule @rss_context: RSS context to be affected @rule_cnt: Number of rules to be affected @rule_locs: Array of used rule locations"],["ethtool_stats","struct ethtool_stats - device-specific statistics @cmd: Command number = %ETHTOOL_GSTATS @n_stats: On return, the number of statistics @data: Array of statistics"],["ethtool_tcpip4_spec","struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc. @ip4src: Source host @ip4dst: Destination host @psrc: Source port @pdst: Destination port @tos: Type-of-service"],["ethtool_tcpip6_spec","struct ethtool_tcpip6_spec - flow specification for TCP/IPv6 etc. @ip6src: Source host @ip6dst: Destination host @psrc: Source port @pdst: Destination port @tclass: Traffic Class"],["ethtool_test","struct ethtool_test - device self-test invocation @cmd: Command number = %ETHTOOL_TEST @flags: A bitmask of flags from &enum ethtool_test_flags.  Some flags may be set by the user on entry; others may be set by the driver on return. @len: On return, the number of test results @data: Array of test results"],["ethtool_ts_info","struct ethtool_ts_info - holds a device's timestamping and PHC association @cmd: command number = %ETHTOOL_GET_TS_INFO @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags @phc_index: device index of the associated PHC, or -1 if there is none @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values"],["ethtool_tunable",""],["ethtool_usrip4_spec","struct ethtool_usrip4_spec - general flow specification for IPv4 @ip4src: Source host @ip4dst: Destination host @l4_4_bytes: First 4 bytes of transport (layer 4) header @tos: Type-of-service @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0 @proto: Transport protocol number; mask must be 0"],["ethtool_usrip6_spec","struct ethtool_usrip6_spec - general flow specification for IPv6 @ip6src: Source host @ip6dst: Destination host @l4_4_bytes: First 4 bytes of transport (layer 4) header @tclass: Traffic Class @l4_proto: Transport protocol number (nexthdr after any Extension Headers)"],["ethtool_wolinfo","struct ethtool_wolinfo - Wake-On-Lan configuration @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes. Read-only. @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes. @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE is set in @wolopts."],["eventfd_ctx",""],["exception_table_entry",""],["export_operations",""],["fasync_struct",""],["fib6_info",""],["fib6_table",""],["fib_kuid_range",""],["fib_lookup_arg",""],["fib_notifier_ops",""],["fib_rule",""],["fib_rule_hdr",""],["fib_rule_port_range",""],["fib_rules_ops",""],["fib_table",""],["fiemap_extent",""],["fiemap_extent_info",""],["file",""],["file_lock",""],["file_lock__bindgen_ty_1__bindgen_ty_1",""],["file_lock_context",""],["file_lock_operations",""],["file_operations",""],["file_ra_state",""],["file_system_type",""],["files_struct",""],["flow_block",""],["flowi",""],["flowi4",""],["flowi6",""],["flowi_common",""],["flowi_tunnel",""],["flowi_uli__bindgen_ty_1",""],["flowi_uli__bindgen_ty_2",""],["flowi_uli__bindgen_ty_3",""],["flowi_uli__bindgen_ty_4",""],["flowidn",""],["fown_struct",""],["fpregs_state",""],["fprop_global",""],["fprop_local_percpu",""],["fpu",""],["fqdir",""],["fr_proto",""],["fr_proto_pvc",""],["fr_proto_pvc_info",""],["frag_v4_compare_key",""],["frag_v6_compare_key",""],["free_area",""],["fregs_state",""],["fs_context",""],["fs_parameter_description",""],["fs_struct",""],["fscrypt_info",""],["fscrypt_operations",""],["fsnotify_mark_connector",""],["fsverity_info",""],["fsverity_operations",""],["ftrace_ret_stack",""],["futex_pi_state",""],["fwnode_endpoint","struct fwnode_endpoint - Fwnode graph endpoint @port: Port number @id: Endpoint id @local_fwnode: reference to the related fwnode"],["fwnode_handle",""],["fwnode_operations","struct fwnode_operations - Operations for fwnode interface @get: Get a reference to an fwnode. @put: Put a reference to an fwnode. @device_get_match_data: Return the device driver match data. @property_present: Return true if a property is present. @property_read_integer_array: Read an array of integer properties. Return zero on success, a negative error code otherwise. @property_read_string_array: Read an array of string properties. Return zero on success, a negative error code otherwise. @get_parent: Return the parent of an fwnode. @get_next_child_node: Return the next child node in an iteration. @get_named_child_node: Return a child node with a given name. @get_reference_args: Return a reference pointed to by a property, with args @graph_get_next_endpoint: Return an endpoint node in an iteration. @graph_get_remote_endpoint: Return the remote endpoint node of a local endpoint node. @graph_get_port_parent: Return the parent node of a port node. @graph_parse_endpoint: Parse endpoint for port and endpoint id."],["fwnode_reference_args","struct fwnode_reference_args - Fwnode reference with additional arguments @fwnode:- A reference to the base fwnode @nargs: Number of elements in @args array @args: Integer arguments on the fwnode"],["fxregs_state",""],["fxregs_state__bindgen_ty_1__bindgen_ty_1",""],["fxregs_state__bindgen_ty_1__bindgen_ty_2",""],["garp_port",""],["gendisk",""],["gnet_dump",""],["gnet_stats_basic_cpu",""],["gnet_stats_basic_packed",""],["gnet_stats_queue","struct gnet_stats_queue - queuing statistics @qlen: queue length @backlog: backlog size of queue @drops: number of dropped packets @requeues: number of requeues @overlimits: number of enqueues over the limit"],["group_info",""],["hd_geometry",""],["hd_struct",""],["header_ops",""],["hh_cache",""],["hlist_bl_head",""],["hlist_bl_node",""],["hlist_head",""],["hlist_node",""],["hlist_nulls_head",""],["hlist_nulls_node",""],["hrtimer","struct hrtimer - the basic hrtimer structure @node:\ttimerqueue node, which also manages node.expires, the absolute expiry time in the hrtimers internal representation. The time is related to the clock on which the timer is based. Is setup by adding slack to the _softexpires value. For non range timers identical to _softexpires. @_softexpires: the absolute earliest expiry time of the hrtimer. The time which was given as expiry time when the timer was armed. @function:\ttimer expiry callback function @base:\tpointer to the timer base (per cpu and per clock) @state:\tstate information (See bit values above) @is_rel:\tSet if the timer was armed relative @is_soft:\tSet if hrtimer will be expired in soft interrupt context. @is_hard:\tSet if hrtimer will be expired in hard interrupt context even on RT."],["hrtimer_clock_base","struct hrtimer_clock_base - the timer base for a specific clock @cpu_base:\t\tper cpu clock base @index:\t\tclock type index for per_cpu support when moving a timer to a base on another cpu. @clockid:\t\tclock id for per_cpu support @seq:\t\tseqcount around __run_hrtimer @running:\t\tpointer to the currently running hrtimer @active:\t\tred black tree root node for the active timers @get_time:\t\tfunction to retrieve the current time of the clock @offset:\t\toffset of this clock to the monotonic base"],["hrtimer_cpu_base","struct hrtimer_cpu_base - the per cpu clock bases @lock:\t\tlock protecting the base and associated clock bases and timers @cpu:\t\tcpu number @active_bases:\tBitfield to mark bases with active timers @clock_was_set_seq:\tSequence counter of clock was set events @hres_active:\tState of high resolution mode @in_hrtirq:\t\thrtimer_interrupt() is currently executing @hang_detected:\tThe last hrtimer interrupt detected a hang @softirq_activated:\tdisplays, if the softirq is raised - update of softirq related settings is not required then. @nr_events:\t\tTotal number of hrtimer interrupt events @nr_retries:\t\tTotal number of hrtimer interrupt retries @nr_hangs:\t\tTotal number of hrtimer interrupt hangs @max_hang_time:\tMaximum time spent in hrtimer_interrupt @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are expired @timer_waiters:\tA hrtimer_cancel() invocation waits for the timer callback to finish. @expires_next:\tabsolute time of the next event, is required for remote hrtimer enqueue; it is the total first expiry time (hard and soft hrtimer are taken into account) @next_timer:\t\tPointer to the first expiring timer @softirq_expires_next: Time to check, if soft queues needs also to be expired @softirq_next_timer: Pointer to the first expiring softirq based timer @clock_base:\t\tarray of clock bases for this cpu"],["iattr",""],["icmp_mib",""],["icmpmsg_mib",""],["icmpv6_mib",""],["icmpv6msg_mib",""],["idr",""],["ieee_ets",""],["ieee_maxrate",""],["ieee_pfc",""],["ieee_qcn",""],["ieee_qcn_stats",""],["if_settings",""],["ifla_vf_info",""],["ifla_vf_stats",""],["ifmap",""],["ifreq",""],["in6_addr","csum_ipv6_magic - Compute checksum of an IPv6 pseudo header. @saddr: source address @daddr: destination address @len: length of packet @proto: protocol of packet @sum: initial sum (32bit unfolded) to be added in"],["in_addr",""],["in_device",""],["inet6_dev",""],["inet_cork",""],["inet_cork_full",""],["inet_frag_queue","struct inet_frag_queue - fragment queue"],["inet_frags",""],["inet_hashinfo",""],["inet_peer_base",""],["inet_sock","struct inet_sock - representation of INET sockets"],["inet_timewait_death_row",""],["inode",""],["inode_operations",""],["io_context",""],["io_cq",""],["iommu_fwspec",""],["iommu_group",""],["iommu_ops",""],["iommu_param",""],["iov_iter",""],["iov_iter__bindgen_ty_2__bindgen_ty_1",""],["iovec",""],["ip_conntrack_stat",""],["ip_mc_socklist",""],["ip_options","struct ip_options - IP Options"],["ip_options_rcu",""],["ip_ra_chain",""],["ipc_namespace",""],["iphdr",""],["ipstats_mib",""],["ipv4_devconf",""],["ipv6_devconf",""],["ipv6_pinfo",""],["irq_domain",""],["iw_handler_def",""],["iw_public_data",""],["jump_entry",""],["k_sigaction",""],["kernel_cap_struct",""],["kernel_param",""],["kernel_param_ops",""],["kernel_siginfo",""],["kernel_siginfo__bindgen_ty_1",""],["kernel_symbol",""],["kernfs_elem_attr",""],["kernfs_elem_dir",""],["kernfs_elem_symlink",""],["kernfs_iattrs",""],["kernfs_node",""],["kernfs_node_id__bindgen_ty_1",""],["kernfs_open_file",""],["kernfs_open_node",""],["kernfs_ops",""],["kernfs_root",""],["kernfs_syscall_ops",""],["key",""],["key__bindgen_ty_3__bindgen_ty_1",""],["key__bindgen_ty_4__bindgen_ty_1",""],["key_restriction",""],["key_tag",""],["key_type",""],["key_user",""],["keyring_index_key",""],["keyring_index_key__bindgen_ty_1__bindgen_ty_1",""],["kgid_t",""],["kiocb",""],["kioctx_table",""],["klp_modinfo",""],["kmem_cache",""],["kobj_ns_type_operations",""],["kobj_type",""],["kobj_uevent_env",""],["kobject",""],["kparam_array",""],["kparam_string",""],["kprojid_t",""],["kqid",""],["kref",""],["kset","struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."],["kset_uevent_ops",""],["kstat",""],["kstatfs",""],["kthread_delayed_work",""],["kthread_work",""],["kthread_worker",""],["kuid_t",""],["kvec",""],["l3mdev_ops","struct l3mdev_ops - l3mdev operations"],["latch_tree_node",""],["ldt_struct",""],["linux_binfmt",""],["linux_mib",""],["linux_xfrm_mib",""],["list_head",""],["list_lru",""],["list_lru_memcg",""],["list_lru_node",""],["list_lru_one",""],["llist_node",""],["load_weight",""],["local_ports",""],["local_t",""],["lock_class_key",""],["lock_manager_operations",""],["lockdep_map",""],["lockref",""],["lockref__bindgen_ty_1__bindgen_ty_1",""],["lruvec",""],["lruvec_stat",""],["lwtunnel_state",""],["math_emu_info",""],["mem_cgroup",""],["mem_cgroup_id",""],["mem_cgroup_per_node",""],["mem_cgroup_reclaim_iter",""],["mem_cgroup_threshold",""],["mem_cgroup_threshold_ary",""],["mem_cgroup_thresholds",""],["mem_dqblk",""],["mem_dqinfo",""],["memcg_cgwb_frn",""],["memcg_padding",""],["memcg_shrinker_map",""],["memcg_vmstats_percpu",""],["mempolicy",""],["mempool_s",""],["mini_Qdisc",""],["mm_context_t",""],["mm_rss_stat",""],["mm_segment_t",""],["mm_struct",""],["mm_struct__bindgen_ty_1",""],["mmu_notifier_mm",""],["mnt_namespace",""],["mod_arch_specific",""],["mod_kallsyms",""],["mod_tree_node",""],["module",""],["module_attribute",""],["module_kobject",""],["module_layout",""],["module_notes_attrs",""],["module_param_attrs",""],["module_sect_attrs",""],["mpls_dev",""],["mpls_route",""],["mrp_port",""],["msghdr",""],["mtd_info",""],["mutex",""],["nameidata",""],["ndisc_ops",""],["ndmsg",""],["neigh_hash_table",""],["neigh_ops",""],["neigh_parms",""],["neigh_statistics",""],["neigh_table",""],["neighbour",""],["net",""],["net_device","struct net_device - The DEVICE structure."],["net_device__bindgen_ty_1",""],["net_device_ops",""],["net_device_stats",""],["net_generic",""],["net_rate_estimator",""],["netdev_bpf",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_1",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_2",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_3",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_4",""],["netdev_fcoe_hbainfo",""],["netdev_hw_addr_list",""],["netdev_phys_item_id",""],["netdev_queue",""],["netdev_rx_queue",""],["netdev_tc_txq",""],["netlink_callback",""],["netlink_ext_ack","struct netlink_ext_ack - netlink extended ACK report struct @_msg: message string to report - don't access directly, use %NL_SET_ERR_MSG @bad_attr: attribute with error @cookie: cookie data to return to userspace (for success) @cookie_len: actual cookie data length"],["netns_can",""],["netns_core",""],["netns_ct",""],["netns_dccp",""],["netns_ieee802154_lowpan",""],["netns_ipv4",""],["netns_ipv6",""],["netns_ipv6__bindgen_ty_1",""],["netns_ipvs",""],["netns_mib",""],["netns_mpls",""],["netns_nexthop",""],["netns_nf",""],["netns_nf_frag",""],["netns_nftables",""],["netns_packet",""],["netns_sctp",""],["netns_sysctl_ipv6",""],["netns_sysctl_lowpan",""],["netns_unix",""],["netns_xdp",""],["netns_xfrm",""],["netns_xt",""],["netpoll_info",""],["netprio_map",""],["nf_ct_event_notifier",""],["nf_dccp_net",""],["nf_exp_event_notifier",""],["nf_generic_net",""],["nf_gre_net",""],["nf_hook_entries",""],["nf_icmp_net",""],["nf_ip_net",""],["nf_logger",""],["nf_queue_handler",""],["nf_sctp_net",""],["nf_tcp_net",""],["nf_udp_net",""],["nfs4_lock_info",""],["nfs4_lock_state",""],["nfs_lock_info",""],["nla_policy","struct nla_policy - attribute validation policy @type: Type of attribute or NLA_UNSPEC @validation_type: type of attribute validation done in addition to type-specific validation (e.g. range, function call), see &enum nla_policy_validation @len: Type specific length of payload"],["nla_policy__bindgen_ty_1__bindgen_ty_1",""],["nlattr",""],["nlm_lockowner",""],["nlmsghdr",""],["nodemask_t",""],["notifier_block",""],["ns_common",""],["nsproxy",""],["numa_group",""],["of_device_id",""],["old_timespec32",""],["optimistic_spin_queue",""],["pacct_struct",""],["page",""],["page__bindgen_ty_1__bindgen_ty_1",""],["page__bindgen_ty_1__bindgen_ty_2",""],["page__bindgen_ty_1__bindgen_ty_3",""],["page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1",""],["page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1",""],["page__bindgen_ty_1__bindgen_ty_4",""],["page__bindgen_ty_1__bindgen_ty_5",""],["page__bindgen_ty_1__bindgen_ty_6",""],["page__bindgen_ty_1__bindgen_ty_7",""],["page_counter",""],["page_frag",""],["partition_meta_info",""],["path",""],["pcpu_dstats",""],["pcpu_lstats",""],["pcpu_sw_netstats",""],["per_cpu_nodestat",""],["per_cpu_pages",""],["per_cpu_pageset",""],["percpu_counter",""],["percpu_ref",""],["percpu_rw_semaphore",""],["perf_event",""],["perf_event_context",""],["pgd_t",""],["pglist_data",""],["pgprot",""],["phy_device",""],["pid",""],["pid_namespace",""],["ping_group_range",""],["pipe_buf_operations",""],["pipe_buffer","struct pipe_buffer - a linux kernel pipe buffer @page: the page containing the data for the pipe buffer @offset: offset of data inside the @page @len: length of data inside the @page @ops: operations associated with this buffer. See @pipe_buf_operations. @flags: pipe buffer flags. See above. @private: private data owned by the ops."],["pipe_inode_info","struct pipe_inode_info - a linux kernel pipe @mutex: mutex protecting the whole thing @wait: reader/writer wait point in case of empty/full pipe @nrbufs: the number of non-empty pipe buffers in this pipe @buffers: total number of buffers (should be a power of 2) @curbuf: the current pipe buffer entry @tmp_page: cached released page @readers: number of current readers of this pipe @writers: number of current writers of this pipe @files: number of struct file referring this pipe (protected by ->i_lock) @waiting_writers: number of writers blocked waiting for room @r_counter: reader counter @w_counter: writer counter @fasync_readers: reader side fasync @fasync_writers: writer side fasync @bufs: the circular array of pipe buffers @user: the user who created this pipe"],["plist_node",""],["pm_domain_data",""],["pm_message",""],["pm_subsys_data",""],["pmd_t",""],["pneigh_entry",""],["poll_table_struct",""],["pollfd",""],["posix_acl",""],["posix_cputimer_base","posix_cputimer_base - Container per posix CPU clock @nextevt:\t\tEarliest-expiration cache @tqhead:\t\ttimerqueue head for cpu_timers"],["posix_cputimers","posix_cputimers - Container for posix CPU timer related data @bases:\t\tBase container for posix CPU clocks @timers_active:\tTimers are queued. @expiry_active:\tTimer expiry is active. Used for process wide timers to avoid multiple task trying to handle expiry concurrently"],["possible_net_t",""],["pr_ops",""],["prev_cputime","struct prev_cputime - snapshot of system and user cputime @utime: time spent in user mode @stime: time spent in system mode @lock: protects the above two fields"],["proc_dir_entry",""],["proc_ns_operations",""],["prot_inuse",""],["proto",""],["proto_ops",""],["psi_group",""],["psi_group_cpu",""],["pt_regs",""],["pte_t",""],["pud_t",""],["qc_dqblk",""],["qc_info",""],["qc_state",""],["qc_type_state",""],["qdisc_size_table",""],["qdisc_skb_cb",""],["qdisc_skb_cb__bindgen_ty_1",""],["qdisc_skb_head",""],["qdisc_walker",""],["qrwlock",""],["qrwlock__bindgen_ty_1__bindgen_ty_1",""],["qspinlock",""],["qspinlock__bindgen_ty_1__bindgen_ty_1",""],["qspinlock__bindgen_ty_1__bindgen_ty_2",""],["qstr",""],["qstr__bindgen_ty_1__bindgen_ty_1",""],["queue_limits",""],["quota_format_ops",""],["quota_format_type",""],["quota_info",""],["quotactl_ops",""],["ratelimit_state",""],["raw_hashinfo",""],["raw_hdlc_proto",""],["raw_spinlock",""],["rb_node",""],["rb_root",""],["rb_root_cached",""],["rcu_segcblist",""],["rcu_sync",""],["rcu_work",""],["rcuwait",""],["read_descriptor_t",""],["reclaim_state",""],["refcount_struct","struct refcount_t - variant of atomic_t specialized for reference counts @refs: atomic_t counter field"],["request",""],["request__bindgen_ty_3__bindgen_ty_1",""],["request__bindgen_ty_3__bindgen_ty_2",""],["request_queue",""],["request_sock",""],["request_sock_ops",""],["resource",""],["restart_block",""],["restart_block__bindgen_ty_1__bindgen_ty_1",""],["restart_block__bindgen_ty_1__bindgen_ty_2",""],["restart_block__bindgen_ty_1__bindgen_ty_3",""],["return_instance",""],["rhash_head",""],["rhash_lock_head",""],["rhashtable","struct rhashtable - Hash table handle @tbl: Bucket table @key_len: Key length for hashfn @max_elems: Maximum number of elements in table @p: Configuration parameters @rhlist: True if this is an rhltable @run_work: Deferred worker to expand/shrink asynchronously @mutex: Mutex to protect current/future table swapping @lock: Spin lock to protect walker list @nelems: Number of elements in table"],["rhashtable_compare_arg","struct rhashtable_compare_arg - Key for the function rhashtable_compare @ht: Hash table @key: Key to compare against"],["rhashtable_params","struct rhashtable_params - Hash table construction parameters @nelem_hint: Hint on number of elements, should be 75% of desired size @key_len: Length of key @key_offset: Offset of key in struct to be hashed @head_offset: Offset of rhash_head in struct to be hashed @max_size: Maximum size while expanding @min_size: Minimum size while shrinking @automatic_shrinking: Enable automatic shrinking of tables @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash) @obj_hashfn: Function to hash object @obj_cmpfn: Function to compare key with object"],["rlimit",""],["robust_list_head",""],["rps_dev_flow",""],["rps_dev_flow_table",""],["rps_map",""],["rq_qos",""],["rseq",""],["rt6_info",""],["rt6_statistics",""],["rt_mutex_waiter",""],["rtnl_link_ops","struct rtnl_link_ops - rtnetlink link operations"],["rtnl_link_stats64",""],["rw_semaphore",""],["rwlock_t",""],["sb_writers",""],["scatterlist",""],["sched_avg",""],["sched_class",""],["sched_dl_entity",""],["sched_entity",""],["sched_info",""],["sched_rt_entity",""],["sched_statistics",""],["sctp_mib",""],["seccomp","struct seccomp - the state of a seccomp'ed process"],["seccomp_filter",""],["seg6_pernet_data",""],["sem_undo_list",""],["seq_file",""],["seq_operations",""],["seqcount",""],["seqlock_t",""],["sfp_bus",""],["sg_io_v4",""],["sg_table",""],["shrink_control",""],["shrinker",""],["sigaction",""],["sighand_struct",""],["signal_struct",""],["sigpending",""],["sigset_t",""],["siphash_key_t",""],["sk_buff","struct sk_buff - socket buffer @next: Next buffer in list @prev: Previous buffer in list @tstamp: Time we arrived/left @rbnode: RB tree node, alternative to next/prev for netem/tcp @sk: Socket we are owned by @dev: Device we arrived on/are leaving by @cb: Control buffer. Free for use by every layer. Put private vars here @_skb_refdst: destination entry (with norefcount bit) @sp: the security path, used for xfrm @len: Length of actual data @data_len: Data length @mac_len: Length of link layer header @hdr_len: writable header length of cloned skb @csum: Checksum (must include start/offset pair) @csum_start: Offset from skb->head where checksumming should start @csum_offset: Offset from csum_start where checksum should be stored @priority: Packet queueing priority @ignore_df: allow local fragmentation @cloned: Head may be cloned (check refcnt to be sure) @ip_summed: Driver fed us an IP checksum @nohdr: Payload reference only, must not modify header @pkt_type: Packet class @fclone: skbuff clone status @ipvs_property: skbuff is owned by ipvs @offload_fwd_mark: Packet was L2-forwarded in hardware @offload_l3_fwd_mark: Packet was L3-forwarded in hardware @tc_skip_classify: do not classify packet. set by IFB device @tc_at_ingress: used within tc_classify to distinguish in/egress @redirected: packet was redirected by packet classifier @from_ingress: packet was redirected from the ingress path @peeked: this packet has been seen already, so stats have been done for it, don't do them again @nf_trace: netfilter packet trace flag @protocol: Packet protocol from driver @destructor: Destruct function @tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue) @_nfct: Associated connection, if any (with nfctinfo bits) @nf_bridge: Saved data about a bridged frame - see br_netfilter.c @skb_iif: ifindex of device we arrived on @tc_index: Traffic control index @hash: the packet hash @queue_mapping: Queue mapping for multiqueue devices @pfmemalloc: skbuff was allocated from PFMEMALLOC reserves @active_extensions: active extensions (skb_ext_id types) @ndisc_nodetype: router type (from link layer) @ooo_okay: allow the mapping of a socket to a queue to be changed @l4_hash: indicate hash is a canonical 4-tuple hash over transport ports. @sw_hash: indicates hash was computed in software stack @wifi_acked_valid: wifi_acked was set @wifi_acked: whether frame was acked on wifi or not @no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS @csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL @dst_pending_confirm: need to confirm neighbour @decrypted: Decrypted SKB @napi_id: id of the NAPI struct this skb came from @secmark: security marking @mark: Generic packet mark @vlan_proto: vlan encapsulation protocol @vlan_tci: vlan tag control information @inner_protocol: Protocol (encapsulation) @inner_transport_header: Inner transport layer header (encapsulation) @inner_network_header: Network layer header (encapsulation) @inner_mac_header: Link layer header (encapsulation) @transport_header: Transport layer header @network_header: Network layer header @mac_header: Link layer header @tail: Tail pointer @end: End pointer @head: Head of buffer @data: Data head pointer @truesize: Buffer size @users: User count - see {datagram,tcp}.c @extensions: allocated extensions, valid if active_extensions is nonzero"],["sk_buff__bindgen_ty_1__bindgen_ty_1",""],["sk_buff__bindgen_ty_4__bindgen_ty_1",""],["sk_buff__bindgen_ty_5__bindgen_ty_1",""],["sk_buff_fclones",""],["sk_buff_head",""],["sk_filter",""],["sk_msg_md",""],["sk_reuseport_md",""],["skb_ext","struct skb_ext - sk_buff extensions @refcnt: 1 on allocation, deallocated on 0 @offset: offset to add to @data to obtain extension address @chunks: size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units @data: start of extension data, variable sized"],["smc_hashinfo",""],["sock","struct sock - network layer representation of sockets @__sk_common: shared layout with inet_timewait_sock @sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN @sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings @sk_lock:\tsynchronizer @sk_kern_sock: True if sock is using kernel lock classes @sk_rcvbuf: size of receive buffer in bytes @sk_wq: sock wait queue and async head @sk_rx_dst: receive input route used by early demux @sk_dst_cache: destination cache @sk_dst_pending_confirm: need to confirm neighbour @sk_policy: flow policy @sk_receive_queue: incoming packets @sk_wmem_alloc: transmit queue bytes committed @sk_tsq_flags: TCP Small Queues flags @sk_write_queue: Packet sending queue @sk_omem_alloc: \"o\" is \"option\" or \"other\" @sk_wmem_queued: persistent queue size @sk_forward_alloc: space allocated forward @sk_napi_id: id of the last napi context to receive data for sk @sk_ll_usec: usecs to busypoll when there is no data @sk_allocation: allocation mode @sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler) @sk_pacing_status: Pacing status (requested, handled by sch_fq) @sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE) @sk_sndbuf: size of send buffer in bytes @__sk_flags_offset: empty field used to determine location of bitfield @sk_padding: unused element for alignment @sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets @sk_no_check_rx: allow zero checksum in RX packets @sk_route_caps: route capabilities (e.g. %NETIF_F_TSO) @sk_route_nocaps: forbidden route capabilities (e.g NETIF_F_GSO_MASK) @sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4) @sk_gso_max_size: Maximum GSO segment size to build @sk_gso_max_segs: Maximum number of GSO segments @sk_pacing_shift: scaling factor for TCP Small Queues @sk_lingertime: %SO_LINGER l_linger setting @sk_backlog: always used with the per-socket spinlock held @sk_callback_lock: used with the callbacks in the end of this struct @sk_error_queue: rarely used @sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt, IPV6_ADDRFORM for instance) @sk_err: last error @sk_err_soft: errors that don't cause failure but are the cause of a persistent failure not just 'timed out' @sk_drops: raw/udp drops counter @sk_ack_backlog: current listen backlog @sk_max_ack_backlog: listen backlog set in listen() @sk_uid: user id of owner @sk_priority: %SO_PRIORITY setting @sk_type: socket type (%SOCK_STREAM, etc) @sk_protocol: which protocol this socket belongs in this network family @sk_peer_pid: &struct pid for this socket's peer @sk_peer_cred: %SO_PEERCRED setting @sk_rcvlowat: %SO_RCVLOWAT setting @sk_rcvtimeo: %SO_RCVTIMEO setting @sk_sndtimeo: %SO_SNDTIMEO setting @sk_txhash: computed flow hash for use on transmit @sk_filter: socket filtering instructions @sk_timer: sock cleanup timer @sk_stamp: time stamp of last packet received @sk_stamp_seq: lock for accessing sk_stamp on 32 bit architectures only @sk_tsflags: SO_TIMESTAMPING socket options @sk_tskey: counter to disambiguate concurrent tstamp requests @sk_zckey: counter to order MSG_ZEROCOPY notifications @sk_socket: Identd and reporting IO signals @sk_user_data: RPC layer private data @sk_frag: cached page frag @sk_peek_off: current peek_offset value @sk_send_head: front of stuff to transmit @sk_security: used by security modules @sk_mark: generic packet mark @sk_cgrp_data: cgroup data for this cgroup @sk_memcg: this socket's memory cgroup association @sk_write_pending: a write to stream socket waits to start @sk_state_change: callback to indicate change in the state of the sock @sk_data_ready: callback to indicate there is data to be processed @sk_write_space: callback to indicate there is bf sending space available @sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE) @sk_backlog_rcv: callback to process the backlog @sk_destruct: called at sock freeing time, i.e. when all refcnt == 0 @sk_reuseport_cb: reuseport group container @sk_rcu: used during RCU grace period @sk_clockid: clockid used by time-based scheduling (SO_TXTIME) @sk_txtime_deadline_mode: set deadline mode for SO_TXTIME @sk_txtime_unused: unused txtime flags"],["sock__bindgen_ty_1",""],["sock_cgroup_data",""],["sock_cgroup_data__bindgen_ty_1__bindgen_ty_1",""],["sock_common","struct sock_common - minimal network layer representation of sockets @skc_daddr: Foreign IPv4 addr @skc_rcv_saddr: Bound local IPv4 addr @skc_hash: hash value used with various protocol lookup tables @skc_u16hashes: two u16 hash values used by UDP lookup tables @skc_dport: placeholder for inet_dport/tw_dport @skc_num: placeholder for inet_num/tw_num @skc_family: network address family @skc_state: Connection state @skc_reuse: %SO_REUSEADDR setting @skc_reuseport: %SO_REUSEPORT setting @skc_bound_dev_if: bound device index if != 0 @skc_bind_node: bind hash linkage for various protocol lookup tables @skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol @skc_prot: protocol handlers inside a network family @skc_net: reference to the network namespace of this socket @skc_node: main hash linkage for various protocol lookup tables @skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol @skc_tx_queue_mapping: tx queue number for this connection @skc_rx_queue_mapping: rx queue number for this connection @skc_flags: place holder for sk_flags %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE, %SO_OOBINLINE settings, %SO_TIMESTAMPING settings @skc_incoming_cpu: record/match cpu processing incoming packets @skc_refcnt: reference count"],["sock_common__bindgen_ty_1__bindgen_ty_1",""],["sock_common__bindgen_ty_3__bindgen_ty_1",""],["sock_filter",""],["sock_fprog_kern",""],["sock_reuseport",""],["sockaddr",""],["sockaddr_in",""],["socket","struct socket - general BSD socket @state: socket state (%SS_CONNECTED, etc) @type: socket type (%SOCK_STREAM, etc) @flags: socket flags (%SOCK_NOSPACE, etc) @ops: protocol specific socket operations @file: File back pointer for gc @sk: internal networking protocol agnostic socket representation @wq: wait queue for several uses"],["socket_lock_t",""],["socket_wq",""],["spinlock",""],["srcu_data",""],["srcu_node",""],["srcu_struct",""],["static_key",""],["static_key_mod",""],["subsys_private",""],["super_block",""],["super_operations",""],["swap_info_struct",""],["swregs_state",""],["sync_serial_settings",""],["sysfs_ops",""],["sysv_sem",""],["sysv_shm",""],["task_cputime","struct task_cputime - collected CPU time counts @stime:\t\ttime spent in kernel mode, in nanoseconds @utime:\t\ttime spent in user mode, in nanoseconds @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"],["task_cputime_atomic",""],["task_delay_info",""],["task_group",""],["task_io_accounting",""],["task_rss_stat",""],["task_struct",""],["taskstats",""],["tc_sizespec",""],["tc_stats",""],["tcf_block",""],["tcf_block__bindgen_ty_1",""],["tcf_chain",""],["tcf_proto",""],["tcf_proto_ops",""],["tcf_result",""],["tcf_result__bindgen_ty_1__bindgen_ty_1",""],["tcf_result__bindgen_ty_1__bindgen_ty_2",""],["tcf_walker",""],["tcmsg","Traffic control messages."],["tcp_congestion_ops",""],["tcp_fastopen_context",""],["tcp_mib",""],["tcphdr",""],["te1_settings",""],["thread_group_cputimer","struct thread_group_cputimer - thread group interval timer counts @cputime_atomic:\tatomic thread group interval timers."],["thread_info",""],["thread_struct",""],["throtl_data",""],["timer_list",""],["timer_rand_state",""],["timerqueue_head",""],["timerqueue_node",""],["timespec64",""],["timewait_sock_ops",""],["tipc_bearer",""],["tlbflush_unmap_batch",""],["tlsdev_ops",""],["trace_eval_map",""],["trace_event_call",""],["tracepoint",""],["tracepoint_func",""],["tty_audit_buf",""],["tty_struct",""],["u64_stats_sync",""],["uclamp_se",""],["ucounts",""],["udp_mib",""],["udp_table",""],["udp_tunnel_info",""],["udphdr",""],["uevent_sock",""],["uid_gid_extent",""],["uid_gid_map",""],["uid_gid_map__bindgen_ty_1__bindgen_ty_1",""],["upid",""],["uprobe",""],["uprobe_task",""],["uprobe_task__bindgen_ty_1__bindgen_ty_1",""],["uprobe_task__bindgen_ty_1__bindgen_ty_2",""],["uprobes_state",""],["user_namespace",""],["user_struct",""],["userfaultfd_ctx",""],["util_est","struct util_est - Estimation utilization of FAIR tasks @enqueued: instantaneous estimated utilization of a task/cpu @ewma:     the Exponential Weighted Moving Average (EWMA) utilization of a task"],["uts_namespace",""],["uuid_t",""],["vdso_image",""],["vfsmount",""],["vlan_info",""],["vm_area_struct",""],["vm_area_struct__bindgen_ty_1",""],["vm_fault",""],["vm_operations_struct",""],["vm_struct",""],["vm_userfaultfd_ctx",""],["vmacache",""],["vmem_altmap","struct vmem_altmap - pre-allocated storage for vmemmap_populate @base_pfn: base of the entire dev_pagemap mapping @reserve: pages mapped, but reserved for driver use (relative to @base) @free: free pages set aside in the mapping for memmap storage @align: pages reserved to meet allocation alignments @alloc: track pages consumed, private to vmemmap_populate()"],["vmpressure",""],["wait_queue_head",""],["wake_irq",""],["wake_q_node",""],["wakeup_source","struct wakeup_source - Representation of wakeup sources"],["wb_completion",""],["wb_domain",""],["wireless_dev",""],["work_struct",""],["workqueue_struct",""],["wpan_dev",""],["writeback_control",""],["xarray",""],["xattr_handler",""],["xdp_frame",""],["xdp_md",""],["xdp_mem_info",""],["xdp_rxq_info",""],["xdp_umem",""],["xfrm_policy",""],["xfrm_policy_hash",""],["xfrm_policy_hthresh",""],["xfrm_state",""],["xfrmdev_ops",""],["xol_area",""],["xps_dev_maps",""],["xps_map",""],["xregs_state",""],["xt_table",""],["zone",""],["zone_padding",""],["zone_reclaim_stat",""],["zonelist",""],["zoneref",""]],"type":[["Elf64_Addr",""],["Elf64_Ehdr",""],["Elf64_Half",""],["Elf64_Off",""],["Elf64_Shdr",""],["Elf64_Sym",""],["Elf64_Word",""],["Elf64_Xword",""],["__addrpair",""],["__be16",""],["__be32",""],["__be64",""],["__kernel_clock_t",""],["__kernel_clockid_t",""],["__kernel_dev_t",""],["__kernel_gid32_t",""],["__kernel_loff_t",""],["__kernel_long_t",""],["__kernel_pid_t",""],["__kernel_sa_family_t",""],["__kernel_size_t",""],["__kernel_ssize_t",""],["__kernel_time64_t",""],["__kernel_timer_t",""],["__kernel_uid32_t",""],["__kernel_ulong_t",""],["__le16",""],["__poll_t",""],["__portpair",""],["__restorefn_t",""],["__s16",""],["__s32",""],["__s64",""],["__s8",""],["__sighandler_t",""],["__signalfn_t",""],["__sigrestore_t",""],["__sum16",""],["__u16",""],["__u32",""],["__u64",""],["__u8",""],["__wsum",""],["_bindgen_ty_110",""],["_bindgen_ty_4",""],["_bindgen_ty_43",""],["_bindgen_ty_48",""],["_bindgen_ty_5",""],["_bindgen_ty_6",""],["_bindgen_ty_7",""],["_cargo_bpf_u16",""],["_cargo_bpf_u32",""],["_cargo_bpf_u64",""],["_cargo_bpf_u8",""],["arch_rwlock_t",""],["arch_spinlock_t",""],["atomic_long_t",""],["bio_end_io_t",""],["blk_qc_t",""],["blk_status_t",""],["blk_zoned_model",""],["blkcnt_t",""],["bool_",""],["bpf_access_type",""],["bpf_adj_room_mode",""],["bpf_arg_type",""],["bpf_attach_type",""],["bpf_aux_classic_check_t",""],["bpf_cgroup_storage_type",""],["bpf_cmd",""],["bpf_convert_ctx_access_t",""],["bpf_ctx_copy_t",""],["bpf_func_id",""],["bpf_hdr_start_off",""],["bpf_jit_fill_hole_t",""],["bpf_lwt_encap_mode",""],["bpf_map_type",""],["bpf_netdev_command",""],["bpf_op_t",""],["bpf_prog_type",""],["bpf_reg_type",""],["bpf_ret_code",""],["bpf_return_type",""],["bpf_stack_build_id_status",""],["bpf_task_fd_type",""],["clockid_t",""],["compat_long_t",""],["compat_uptr_t",""],["congested_fn",""],["cpumask_t",""],["dev_t",""],["dl_dev_state","enum dl_dev_state - Device driver presence tracking information. @DL_DEV_NO_DRIVER: There is no driver attached to the device. @DL_DEV_PROBING: A driver is probing. @DL_DEV_DRIVER_BOUND: The driver has been bound to the device. @DL_DEV_UNBINDING: The driver is unbinding from the device."],["dma_addr_t",""],["dma_data_direction",""],["dma_drain_needed_fn",""],["elv_merge",""],["errseq_t",""],["ethtool_phys_id_state","enum ethtool_phys_id_state - indicator state for physical identification @ETHTOOL_ID_INACTIVE: Physical ID indicator should be deactivated @ETHTOOL_ID_ACTIVE: Physical ID indicator should be activated @ETHTOOL_ID_ON: LED should be turned on (used iff %ETHTOOL_ID_ACTIVE is not supported) @ETHTOOL_ID_OFF: LED should be turned off (used iff %ETHTOOL_ID_ACTIVE is not supported)"],["filldir_t",""],["fl_owner_t",""],["flow_setup_cb_t",""],["fmode_t",""],["gfp_t",""],["gid_t",""],["hrtimer_restart",""],["integrity_complete_fn",""],["integrity_prepare_fn",""],["integrity_processing_fn",""],["isolate_mode_t",""],["kernel_cap_t",""],["kernel_siginfo_t",""],["key_perm_t",""],["key_restrict_link_func_t",""],["key_serial_t",""],["kobj_ns_type",""],["kthread_work_func_t",""],["ktime_t",""],["loff_t",""],["make_request_fn",""],["memcg_kmem_state",""],["memory_type",""],["mempool_alloc_t",""],["mempool_free_t",""],["mempool_t",""],["migrate_mode",""],["module_state",""],["mq_rq_state",""],["net_device__bindgen_ty_2",""],["net_device__bindgen_ty_3",""],["netdev_features_t",""],["netdev_tx",""],["netdev_tx_t",""],["notifier_fn_t",""],["old_time32_t",""],["page_entry_size",""],["percpu_ref_func_t",""],["pgdval_t",""],["pgprot_t",""],["pgprotval_t",""],["pgtable_t",""],["phys_addr_t",""],["pid_t",""],["pid_type",""],["pm_message_t",""],["pmdval_t",""],["poll_queue_proc",""],["probe_type","enum probe_type - device driver probe type to try Device drivers may opt in for special handling of their respective probe routines. This tells the core what to expect and prefer."],["proc_handler",""],["projid_t",""],["pteval_t",""],["pudval_t",""],["qsize_t",""],["quota_type",""],["raw_spinlock_t",""],["refcount_t","struct refcount_t - variant of atomic_t specialized for reference counts @refs: atomic_t counter field"],["req_flags_t",""],["resource_size_t",""],["rht_hashfn_t",""],["rht_obj_cmpfn_t",""],["rht_obj_hashfn_t",""],["rpm_request",""],["rpm_status",""],["rq_end_io_fn",""],["rw_hint",""],["rx_handler_func_t",""],["rx_handler_result",""],["rx_handler_result_t",""],["s16",""],["s32",""],["s64",""],["s8",""],["sa_family_t",""],["sector_t","The type used for indexing onto a disc or disc partition."],["seqcount_t",""],["sigval_t",""],["size_t",""],["sk_action",""],["sk_buff_data_t",""],["sk_pacing",""],["sk_read_actor_t",""],["slab_flags_t",""],["smp_call_func_t",""],["socket_state",""],["spinlock_t",""],["ssize_t",""],["tc_setup_type",""],["time64_t",""],["timespec_type",""],["tracepoint_ptr_t",""],["uid_t",""],["umode_t",""],["uprobe_task_state",""],["vm_fault_t","typedef vm_fault_t - Return type for page fault handlers."],["wait_queue_head_t",""],["wb_reason",""],["work_func_t",""],["writeback_sync_modes",""],["xdp_action",""],["zone_type",""]],"union":[["__sifields",""],["__sifields__bindgen_ty_5__bindgen_ty_1",""],["__sk_buff__bindgen_ty_1",""],["__sk_buff__bindgen_ty_2",""],["bdi_writeback__bindgen_ty_1",""],["bio__bindgen_ty_1",""],["bpf_attr",""],["bpf_attr__bindgen_ty_2__bindgen_ty_1",""],["bpf_attr__bindgen_ty_7__bindgen_ty_1",""],["bpf_cgroup_storage__bindgen_ty_1",""],["bpf_fib_lookup__bindgen_ty_1",""],["bpf_fib_lookup__bindgen_ty_2",""],["bpf_fib_lookup__bindgen_ty_3",""],["bpf_flow_keys__bindgen_ty_1",""],["bpf_prog_aux__bindgen_ty_1",""],["bpf_sock_addr__bindgen_ty_1",""],["bpf_sock_ops__bindgen_ty_1",""],["bpf_sock_ops__bindgen_ty_2",""],["bpf_sock_ops_kern__bindgen_ty_1",""],["bpf_sock_tuple__bindgen_ty_1",""],["bpf_sockopt__bindgen_ty_1",""],["bpf_sockopt__bindgen_ty_2",""],["bpf_sockopt__bindgen_ty_3",""],["bpf_stack_build_id__bindgen_ty_1",""],["bpf_tunnel_key__bindgen_ty_1",""],["bpf_xfrm_state__bindgen_ty_1",""],["cred__bindgen_ty_1",""],["ctl_table_header__bindgen_ty_1",""],["dentry__bindgen_ty_1",""],["dentry__bindgen_ty_2",""],["ethtool_flow_union",""],["ethtool_rxnfc__bindgen_ty_1",""],["file__bindgen_ty_1",""],["file_lock__bindgen_ty_1",""],["flowi__bindgen_ty_1",""],["flowi_uli",""],["fxregs_state__bindgen_ty_1",""],["fxregs_state__bindgen_ty_2",""],["if_settings__bindgen_ty_1",""],["ifreq__bindgen_ty_1",""],["ifreq__bindgen_ty_2",""],["in6_addr__bindgen_ty_1",""],["inet_frag_queue__bindgen_ty_1",""],["inode__bindgen_ty_1",""],["inode__bindgen_ty_2",""],["inode__bindgen_ty_3",""],["inode__bindgen_ty_4",""],["io_cq__bindgen_ty_1",""],["io_cq__bindgen_ty_2",""],["iov_iter__bindgen_ty_1",""],["iov_iter__bindgen_ty_2",""],["kernel_param__bindgen_ty_1",""],["kernfs_node__bindgen_ty_1",""],["kernfs_node_id",""],["key__bindgen_ty_1",""],["key__bindgen_ty_2",""],["key__bindgen_ty_3",""],["key__bindgen_ty_4",""],["key_payload",""],["keyring_index_key__bindgen_ty_1",""],["kqid__bindgen_ty_1",""],["lockref__bindgen_ty_1",""],["net_device__bindgen_ty_4",""],["netdev_bpf__bindgen_ty_1",""],["netlink_callback__bindgen_ty_1",""],["nla_policy__bindgen_ty_1",""],["page__bindgen_ty_1",""],["page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1",""],["page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2",""],["page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1",""],["page__bindgen_ty_2",""],["proto__bindgen_ty_1",""],["qrwlock__bindgen_ty_1",""],["qspinlock__bindgen_ty_1",""],["qstr__bindgen_ty_1",""],["read_descriptor_t__bindgen_ty_1",""],["request__bindgen_ty_1",""],["request__bindgen_ty_2",""],["request__bindgen_ty_3",""],["request__bindgen_ty_4",""],["restart_block__bindgen_ty_1",""],["restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1",""],["rseq__bindgen_ty_1",""],["sigval",""],["sk_buff__bindgen_ty_1",""],["sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1",""],["sk_buff__bindgen_ty_2",""],["sk_buff__bindgen_ty_3",""],["sk_buff__bindgen_ty_4",""],["sk_buff__bindgen_ty_5",""],["sk_buff__bindgen_ty_6",""],["sk_buff__bindgen_ty_7",""],["sk_buff__bindgen_ty_8",""],["sk_msg_md__bindgen_ty_1",""],["sk_msg_md__bindgen_ty_2",""],["sk_reuseport_md__bindgen_ty_1",""],["sk_reuseport_md__bindgen_ty_2",""],["sock__bindgen_ty_2",""],["sock__bindgen_ty_3",""],["sock_cgroup_data__bindgen_ty_1",""],["sock_common__bindgen_ty_1",""],["sock_common__bindgen_ty_2",""],["sock_common__bindgen_ty_3",""],["sock_common__bindgen_ty_4",""],["sock_common__bindgen_ty_5",""],["sock_common__bindgen_ty_6",""],["sock_common__bindgen_ty_7",""],["sock_common__bindgen_ty_8",""],["spinlock__bindgen_ty_1",""],["static_key__bindgen_ty_1",""],["task_struct__bindgen_ty_1",""],["tcf_result__bindgen_ty_1",""],["uid_gid_map__bindgen_ty_1",""],["uprobe_task__bindgen_ty_1",""]]});