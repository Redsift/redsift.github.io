initSidebarItems({"constant":[["AF_ALG",""],["AF_APPLETALK",""],["AF_ASH",""],["AF_ATMPVC",""],["AF_ATMSVC",""],["AF_AX25",""],["AF_BLUETOOTH",""],["AF_BRIDGE",""],["AF_CAIF",""],["AF_CAN",""],["AF_DECnet",""],["AF_ECONET",""],["AF_IB",""],["AF_IEEE802154",""],["AF_INET",""],["AF_INET6",""],["AF_IPX",""],["AF_IRDA",""],["AF_ISDN",""],["AF_IUCV",""],["AF_KCM",""],["AF_KEY",""],["AF_LLC",""],["AF_LOCAL",""],["AF_MAX",""],["AF_MPLS",""],["AF_NETBEUI",""],["AF_NETLINK",""],["AF_NETROM",""],["AF_NFC",""],["AF_PACKET",""],["AF_PHONET",""],["AF_PPPOX",""],["AF_QIPCRTR",""],["AF_RDS",""],["AF_ROSE",""],["AF_ROUTE",""],["AF_RXRPC",""],["AF_SECURITY",""],["AF_SMC",""],["AF_SNA",""],["AF_TIPC",""],["AF_UNIX",""],["AF_UNSPEC",""],["AF_VSOCK",""],["AF_WANPIPE",""],["AF_X25",""],["BPF_A",""],["BPF_ABS",""],["BPF_ADD",""],["BPF_ALU",""],["BPF_ALU64",""],["BPF_AND",""],["BPF_ANY",""],["BPF_ARSH",""],["BPF_B",""],["BPF_CALL",""],["BPF_CALL_ARGS",""],["BPF_DEVCG_ACC_MKNOD",""],["BPF_DEVCG_ACC_READ",""],["BPF_DEVCG_ACC_WRITE",""],["BPF_DEVCG_DEV_BLOCK",""],["BPF_DEVCG_DEV_CHAR",""],["BPF_DIV",""],["BPF_DW",""],["BPF_END",""],["BPF_EXIST",""],["BPF_EXIT",""],["BPF_FROM_BE",""],["BPF_FROM_LE",""],["BPF_FS_MAGIC",""],["BPF_F_ALLOW_MULTI",""],["BPF_F_ALLOW_OVERRIDE",""],["BPF_F_CTXLEN_MASK",""],["BPF_F_CURRENT_CPU",""],["BPF_F_DONT_FRAGMENT",""],["BPF_F_FAST_STACK_CMP",""],["BPF_F_HDR_FIELD_MASK",""],["BPF_F_INDEX_MASK",""],["BPF_F_INGRESS",""],["BPF_F_INVALIDATE_HASH",""],["BPF_F_MARK_ENFORCE",""],["BPF_F_MARK_MANGLED_0",""],["BPF_F_NO_COMMON_LRU",""],["BPF_F_NO_PREALLOC",""],["BPF_F_NUMA_NODE",""],["BPF_F_PSEUDO_HDR",""],["BPF_F_QUERY_EFFECTIVE",""],["BPF_F_RDONLY",""],["BPF_F_RECOMPUTE_CSUM",""],["BPF_F_REUSE_STACKID",""],["BPF_F_SKIP_FIELD_MASK",""],["BPF_F_STRICT_ALIGNMENT",""],["BPF_F_TUNINFO_IPV6",""],["BPF_F_USER_STACK",""],["BPF_F_WRONLY",""],["BPF_F_ZERO_CSUM_TX",""],["BPF_H",""],["BPF_IMM",""],["BPF_IND",""],["BPF_JA",""],["BPF_JEQ",""],["BPF_JGE",""],["BPF_JGT",""],["BPF_JLE",""],["BPF_JLT",""],["BPF_JMP",""],["BPF_JNE",""],["BPF_JSET",""],["BPF_JSGE",""],["BPF_JSGT",""],["BPF_JSLE",""],["BPF_JSLT",""],["BPF_K",""],["BPF_LD",""],["BPF_LDX",""],["BPF_LEN",""],["BPF_LL_OFF",""],["BPF_LSH",""],["BPF_MAJOR_VERSION",""],["BPF_MAXINSNS",""],["BPF_MEM",""],["BPF_MEMWORDS",""],["BPF_MINOR_VERSION",""],["BPF_MISC",""],["BPF_MOD",""],["BPF_MOV",""],["BPF_MSH",""],["BPF_MUL",""],["BPF_NEG",""],["BPF_NET_OFF",""],["BPF_NOEXIST",""],["BPF_OBJ_NAME_LEN",""],["BPF_OR",""],["BPF_PSEUDO_CALL",""],["BPF_PSEUDO_MAP_FD",""],["BPF_REG_0",""],["BPF_REG_1",""],["BPF_REG_10",""],["BPF_REG_2",""],["BPF_REG_3",""],["BPF_REG_4",""],["BPF_REG_5",""],["BPF_REG_6",""],["BPF_REG_7",""],["BPF_REG_8",""],["BPF_REG_9",""],["BPF_RET",""],["BPF_RSH",""],["BPF_SKB_CB_LEN",""],["BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB",""],["BPF_SOCK_OPS_ALL_CB_FLAGS",""],["BPF_SOCK_OPS_BASE_RTT",""],["BPF_SOCK_OPS_NEEDS_ECN",""],["BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB",""],["BPF_SOCK_OPS_RETRANS_CB",""],["BPF_SOCK_OPS_RETRANS_CB_FLAG",""],["BPF_SOCK_OPS_RTO_CB",""],["BPF_SOCK_OPS_RTO_CB_FLAG",""],["BPF_SOCK_OPS_RWND_INIT",""],["BPF_SOCK_OPS_STATE_CB",""],["BPF_SOCK_OPS_STATE_CB_FLAG",""],["BPF_SOCK_OPS_TCP_CONNECT_CB",""],["BPF_SOCK_OPS_TIMEOUT_INIT",""],["BPF_SOCK_OPS_VOID",""],["BPF_ST",""],["BPF_STX",""],["BPF_SUB",""],["BPF_SYM_ELF_TYPE",""],["BPF_TAG_SIZE",""],["BPF_TAIL_CALL",""],["BPF_TAX",""],["BPF_TCP_CLOSE",""],["BPF_TCP_CLOSE_WAIT",""],["BPF_TCP_CLOSING",""],["BPF_TCP_ESTABLISHED",""],["BPF_TCP_FIN_WAIT1",""],["BPF_TCP_FIN_WAIT2",""],["BPF_TCP_LAST_ACK",""],["BPF_TCP_LISTEN",""],["BPF_TCP_MAX_STATES",""],["BPF_TCP_NEW_SYN_RECV",""],["BPF_TCP_SYN_RECV",""],["BPF_TCP_SYN_SENT",""],["BPF_TCP_TIME_WAIT",""],["BPF_TO_BE",""],["BPF_TO_LE",""],["BPF_TXA",""],["BPF_W",""],["BPF_X",""],["BPF_XADD",""],["BPF_XOR",""],["ETH_ALEN",""],["ETH_DATA_LEN",""],["ETH_FCS_LEN",""],["ETH_FRAME_LEN",""],["ETH_FW_DUMP_DISABLE",""],["ETH_GSTRING_LEN",""],["ETH_HLEN",""],["ETH_MAX_MTU",""],["ETH_MDIO_SUPPORTS_C22",""],["ETH_MDIO_SUPPORTS_C45",""],["ETH_MIN_MTU",""],["ETH_MODULE_SFF_8079",""],["ETH_MODULE_SFF_8079_LEN",""],["ETH_MODULE_SFF_8436",""],["ETH_MODULE_SFF_8436_LEN",""],["ETH_MODULE_SFF_8472",""],["ETH_MODULE_SFF_8472_LEN",""],["ETH_MODULE_SFF_8636",""],["ETH_MODULE_SFF_8636_LEN",""],["ETH_P_1588",""],["ETH_P_8021AD",""],["ETH_P_8021AH",""],["ETH_P_8021Q",""],["ETH_P_80221",""],["ETH_P_802_2",""],["ETH_P_802_3",""],["ETH_P_802_3_MIN",""],["ETH_P_802_EX1",""],["ETH_P_AARP",""],["ETH_P_AF_IUCV",""],["ETH_P_ALL",""],["ETH_P_AOE",""],["ETH_P_ARCNET",""],["ETH_P_ARP",""],["ETH_P_ATALK",""],["ETH_P_ATMFATE",""],["ETH_P_ATMMPOA",""],["ETH_P_AX25",""],["ETH_P_BATMAN",""],["ETH_P_BPQ",""],["ETH_P_CAIF",""],["ETH_P_CAN",""],["ETH_P_CANFD",""],["ETH_P_CONTROL",""],["ETH_P_CUST",""],["ETH_P_DDCMP",""],["ETH_P_DEC",""],["ETH_P_DIAG",""],["ETH_P_DNA_DL",""],["ETH_P_DNA_RC",""],["ETH_P_DNA_RT",""],["ETH_P_DSA",""],["ETH_P_ECONET",""],["ETH_P_EDSA",""],["ETH_P_ERSPAN",""],["ETH_P_ERSPAN2",""],["ETH_P_FCOE",""],["ETH_P_FIP",""],["ETH_P_HDLC",""],["ETH_P_HSR",""],["ETH_P_IBOE",""],["ETH_P_IEEE802154",""],["ETH_P_IEEEPUP",""],["ETH_P_IEEEPUPAT",""],["ETH_P_IFE",""],["ETH_P_IP",""],["ETH_P_IPV6",""],["ETH_P_IPX",""],["ETH_P_IRDA",""],["ETH_P_LAT",""],["ETH_P_LINK_CTL",""],["ETH_P_LOCALTALK",""],["ETH_P_LOOP",""],["ETH_P_LOOPBACK",""],["ETH_P_MACSEC",""],["ETH_P_MAP",""],["ETH_P_MOBITEX",""],["ETH_P_MPLS_MC",""],["ETH_P_MPLS_UC",""],["ETH_P_MVRP",""],["ETH_P_NCSI",""],["ETH_P_NSH",""],["ETH_P_PAE",""],["ETH_P_PAUSE",""],["ETH_P_PHONET",""],["ETH_P_PPPTALK",""],["ETH_P_PPP_DISC",""],["ETH_P_PPP_MP",""],["ETH_P_PPP_SES",""],["ETH_P_PRP",""],["ETH_P_PUP",""],["ETH_P_PUPAT",""],["ETH_P_QINQ1",""],["ETH_P_QINQ2",""],["ETH_P_QINQ3",""],["ETH_P_RARP",""],["ETH_P_SCA",""],["ETH_P_SLOW",""],["ETH_P_SNAP",""],["ETH_P_TDLS",""],["ETH_P_TEB",""],["ETH_P_TIPC",""],["ETH_P_TRAILER",""],["ETH_P_TR_802_2",""],["ETH_P_TSN",""],["ETH_P_WAN_PPP",""],["ETH_P_WCCP",""],["ETH_P_X25",""],["ETH_P_XDSA",""],["ETH_RESET_SHARED_SHIFT",""],["ETH_RSS_HASH_CRC32_BIT",""],["ETH_RSS_HASH_FUNCS_COUNT",""],["ETH_RSS_HASH_NO_CHANGE",""],["ETH_RSS_HASH_TOP_BIT",""],["ETH_RSS_HASH_UNKNOWN",""],["ETH_RSS_HASH_XOR_BIT",""],["ETH_RXFH_INDIR_NO_CHANGE",""],["ETH_RX_NFC_IP4",""],["ETH_TLEN",""],["ETH_TP_MDI",""],["ETH_TP_MDI_AUTO",""],["ETH_TP_MDI_INVALID",""],["ETH_TP_MDI_X",""],["ETH_ZLEN",""],["IPPROTO_AH",""],["IPPROTO_BEETPH",""],["IPPROTO_COMP",""],["IPPROTO_DCCP",""],["IPPROTO_DSTOPTS",""],["IPPROTO_EGP",""],["IPPROTO_ENCAP",""],["IPPROTO_ESP",""],["IPPROTO_FRAGMENT",""],["IPPROTO_GRE",""],["IPPROTO_HOPOPTS",""],["IPPROTO_ICMP",""],["IPPROTO_ICMPV6",""],["IPPROTO_IDP",""],["IPPROTO_IGMP",""],["IPPROTO_IP",""],["IPPROTO_IPIP",""],["IPPROTO_IPV6",""],["IPPROTO_MAX",""],["IPPROTO_MH",""],["IPPROTO_MPLS",""],["IPPROTO_MTP",""],["IPPROTO_NONE",""],["IPPROTO_PIM",""],["IPPROTO_PUP",""],["IPPROTO_RAW",""],["IPPROTO_ROUTING",""],["IPPROTO_RSVP",""],["IPPROTO_SCTP",""],["IPPROTO_TCP",""],["IPPROTO_TP",""],["IPPROTO_UDP",""],["IPPROTO_UDPLITE",""],["SK_FL_PROTO_MASK",""],["SK_FL_PROTO_SHIFT",""],["SK_FL_TYPE_MASK",""],["SK_FL_TYPE_SHIFT",""],["SOCK_BINDADDR_LOCK",""],["SOCK_BINDPORT_LOCK",""],["SOCK_CLOEXEC",""],["SOCK_DESTROY_TIME",""],["SOCK_IOC_TYPE",""],["SOCK_NONBLOCK",""],["SOCK_NOSPACE",""],["SOCK_PASSCRED",""],["SOCK_PASSSEC",""],["SOCK_RCVBUF_LOCK",""],["SOCK_SNDBUF_LOCK",""],["SOCK_TYPE_MASK",""],["SOCK_WAKE_IO",""],["SOCK_WAKE_SPACE",""],["SOCK_WAKE_URG",""],["SOCK_WAKE_WAITD",""],["__MAX_BPF_REG",""],["bpf_adj_room_mode_BPF_ADJ_ROOM_NET",""],["bpf_attach_type_BPF_CGROUP_DEVICE",""],["bpf_attach_type_BPF_CGROUP_INET_EGRESS",""],["bpf_attach_type_BPF_CGROUP_INET_INGRESS",""],["bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE",""],["bpf_attach_type_BPF_CGROUP_SOCK_OPS",""],["bpf_attach_type_BPF_SK_SKB_STREAM_PARSER",""],["bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT",""],["bpf_attach_type___MAX_BPF_ATTACH_TYPE",""],["bpf_cmd_BPF_MAP_CREATE",""],["bpf_cmd_BPF_MAP_DELETE_ELEM",""],["bpf_cmd_BPF_MAP_GET_FD_BY_ID",""],["bpf_cmd_BPF_MAP_GET_NEXT_ID",""],["bpf_cmd_BPF_MAP_GET_NEXT_KEY",""],["bpf_cmd_BPF_MAP_LOOKUP_ELEM",""],["bpf_cmd_BPF_MAP_UPDATE_ELEM",""],["bpf_cmd_BPF_OBJ_GET",""],["bpf_cmd_BPF_OBJ_GET_INFO_BY_FD",""],["bpf_cmd_BPF_OBJ_PIN",""],["bpf_cmd_BPF_PROG_ATTACH",""],["bpf_cmd_BPF_PROG_DETACH",""],["bpf_cmd_BPF_PROG_GET_FD_BY_ID",""],["bpf_cmd_BPF_PROG_GET_NEXT_ID",""],["bpf_cmd_BPF_PROG_LOAD",""],["bpf_cmd_BPF_PROG_QUERY",""],["bpf_cmd_BPF_PROG_TEST_RUN",""],["bpf_func_id_BPF_FUNC_clone_redirect",""],["bpf_func_id_BPF_FUNC_csum_diff",""],["bpf_func_id_BPF_FUNC_csum_update",""],["bpf_func_id_BPF_FUNC_current_task_under_cgroup",""],["bpf_func_id_BPF_FUNC_get_cgroup_classid",""],["bpf_func_id_BPF_FUNC_get_current_comm",""],["bpf_func_id_BPF_FUNC_get_current_pid_tgid",""],["bpf_func_id_BPF_FUNC_get_current_task",""],["bpf_func_id_BPF_FUNC_get_current_uid_gid",""],["bpf_func_id_BPF_FUNC_get_hash_recalc",""],["bpf_func_id_BPF_FUNC_get_numa_node_id",""],["bpf_func_id_BPF_FUNC_get_prandom_u32",""],["bpf_func_id_BPF_FUNC_get_route_realm",""],["bpf_func_id_BPF_FUNC_get_smp_processor_id",""],["bpf_func_id_BPF_FUNC_get_socket_cookie",""],["bpf_func_id_BPF_FUNC_get_socket_uid",""],["bpf_func_id_BPF_FUNC_get_stackid",""],["bpf_func_id_BPF_FUNC_getsockopt",""],["bpf_func_id_BPF_FUNC_ktime_get_ns",""],["bpf_func_id_BPF_FUNC_l3_csum_replace",""],["bpf_func_id_BPF_FUNC_l4_csum_replace",""],["bpf_func_id_BPF_FUNC_map_delete_elem",""],["bpf_func_id_BPF_FUNC_map_lookup_elem",""],["bpf_func_id_BPF_FUNC_map_update_elem",""],["bpf_func_id_BPF_FUNC_override_return",""],["bpf_func_id_BPF_FUNC_perf_event_output",""],["bpf_func_id_BPF_FUNC_perf_event_read",""],["bpf_func_id_BPF_FUNC_perf_event_read_value",""],["bpf_func_id_BPF_FUNC_perf_prog_read_value",""],["bpf_func_id_BPF_FUNC_probe_read",""],["bpf_func_id_BPF_FUNC_probe_read_str",""],["bpf_func_id_BPF_FUNC_probe_write_user",""],["bpf_func_id_BPF_FUNC_redirect",""],["bpf_func_id_BPF_FUNC_redirect_map",""],["bpf_func_id_BPF_FUNC_set_hash",""],["bpf_func_id_BPF_FUNC_set_hash_invalid",""],["bpf_func_id_BPF_FUNC_setsockopt",""],["bpf_func_id_BPF_FUNC_sk_redirect_map",""],["bpf_func_id_BPF_FUNC_skb_adjust_room",""],["bpf_func_id_BPF_FUNC_skb_change_head",""],["bpf_func_id_BPF_FUNC_skb_change_proto",""],["bpf_func_id_BPF_FUNC_skb_change_tail",""],["bpf_func_id_BPF_FUNC_skb_change_type",""],["bpf_func_id_BPF_FUNC_skb_get_tunnel_key",""],["bpf_func_id_BPF_FUNC_skb_get_tunnel_opt",""],["bpf_func_id_BPF_FUNC_skb_load_bytes",""],["bpf_func_id_BPF_FUNC_skb_pull_data",""],["bpf_func_id_BPF_FUNC_skb_set_tunnel_key",""],["bpf_func_id_BPF_FUNC_skb_set_tunnel_opt",""],["bpf_func_id_BPF_FUNC_skb_store_bytes",""],["bpf_func_id_BPF_FUNC_skb_under_cgroup",""],["bpf_func_id_BPF_FUNC_skb_vlan_pop",""],["bpf_func_id_BPF_FUNC_skb_vlan_push",""],["bpf_func_id_BPF_FUNC_sock_map_update",""],["bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set",""],["bpf_func_id_BPF_FUNC_tail_call",""],["bpf_func_id_BPF_FUNC_trace_printk",""],["bpf_func_id_BPF_FUNC_unspec",""],["bpf_func_id_BPF_FUNC_xdp_adjust_head",""],["bpf_func_id_BPF_FUNC_xdp_adjust_meta",""],["bpf_func_id___BPF_FUNC_MAX_ID",""],["bpf_map_type_BPF_MAP_TYPE_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS",""],["bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_CPUMAP",""],["bpf_map_type_BPF_MAP_TYPE_DEVMAP",""],["bpf_map_type_BPF_MAP_TYPE_HASH",""],["bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS",""],["bpf_map_type_BPF_MAP_TYPE_LPM_TRIE",""],["bpf_map_type_BPF_MAP_TYPE_LRU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH",""],["bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY",""],["bpf_map_type_BPF_MAP_TYPE_SOCKMAP",""],["bpf_map_type_BPF_MAP_TYPE_STACK_TRACE",""],["bpf_map_type_BPF_MAP_TYPE_UNSPEC",""],["bpf_netdev_command_BPF_OFFLOAD_DESTROY",""],["bpf_netdev_command_BPF_OFFLOAD_MAP_ALLOC",""],["bpf_netdev_command_BPF_OFFLOAD_MAP_FREE",""],["bpf_netdev_command_BPF_OFFLOAD_TRANSLATE",""],["bpf_netdev_command_BPF_OFFLOAD_VERIFIER_PREP",""],["bpf_netdev_command_XDP_QUERY_PROG",""],["bpf_netdev_command_XDP_SETUP_PROG",""],["bpf_netdev_command_XDP_SETUP_PROG_HW",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB",""],["bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK",""],["bpf_prog_type_BPF_PROG_TYPE_KPROBE",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_IN",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_OUT",""],["bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT",""],["bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT",""],["bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT",""],["bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS",""],["bpf_prog_type_BPF_PROG_TYPE_SK_SKB",""],["bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER",""],["bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS",""],["bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT",""],["bpf_prog_type_BPF_PROG_TYPE_UNSPEC",""],["bpf_prog_type_BPF_PROG_TYPE_XDP",""],["bpf_ret_code_BPF_DROP",""],["bpf_ret_code_BPF_OK",""],["bpf_ret_code_BPF_REDIRECT",""],["dl_dev_state_DL_DEV_DRIVER_BOUND",""],["dl_dev_state_DL_DEV_NO_DRIVER",""],["dl_dev_state_DL_DEV_PROBING",""],["dl_dev_state_DL_DEV_UNBINDING",""],["dma_data_direction_DMA_BIDIRECTIONAL",""],["dma_data_direction_DMA_FROM_DEVICE",""],["dma_data_direction_DMA_NONE",""],["dma_data_direction_DMA_TO_DEVICE",""],["ethtool_phys_id_state_ETHTOOL_ID_ACTIVE",""],["ethtool_phys_id_state_ETHTOOL_ID_INACTIVE",""],["ethtool_phys_id_state_ETHTOOL_ID_OFF",""],["ethtool_phys_id_state_ETHTOOL_ID_ON",""],["hrtimer_restart_HRTIMER_NORESTART",""],["hrtimer_restart_HRTIMER_RESTART",""],["kobj_ns_type_KOBJ_NS_TYPES",""],["kobj_ns_type_KOBJ_NS_TYPE_NET",""],["kobj_ns_type_KOBJ_NS_TYPE_NONE",""],["memcg_kmem_state_KMEM_ALLOCATED",""],["memcg_kmem_state_KMEM_NONE",""],["memcg_kmem_state_KMEM_ONLINE",""],["memory_type_MEMORY_DEVICE_HOST",""],["memory_type_MEMORY_DEVICE_PRIVATE",""],["memory_type_MEMORY_DEVICE_PUBLIC",""],["migrate_mode_MIGRATE_ASYNC",""],["migrate_mode_MIGRATE_SYNC",""],["migrate_mode_MIGRATE_SYNC_LIGHT",""],["migrate_mode_MIGRATE_SYNC_NO_COPY",""],["module_state_MODULE_STATE_COMING",""],["module_state_MODULE_STATE_GOING",""],["module_state_MODULE_STATE_LIVE",""],["module_state_MODULE_STATE_UNFORMED",""],["net_device_NETREG_DUMMY",""],["net_device_NETREG_REGISTERED",""],["net_device_NETREG_RELEASED",""],["net_device_NETREG_UNINITIALIZED",""],["net_device_NETREG_UNREGISTERED",""],["net_device_NETREG_UNREGISTERING",""],["net_device_RTNL_LINK_INITIALIZED",""],["net_device_RTNL_LINK_INITIALIZING",""],["netdev_tx_NETDEV_TX_BUSY",""],["netdev_tx_NETDEV_TX_OK",""],["netdev_tx___NETDEV_TX_MIN",""],["nf_bridge_info_BRNF_PROTO_8021Q",""],["nf_bridge_info_BRNF_PROTO_PPPOE",""],["nf_bridge_info_BRNF_PROTO_UNCHANGED",""],["page_entry_size_PE_SIZE_PMD",""],["page_entry_size_PE_SIZE_PTE",""],["page_entry_size_PE_SIZE_PUD",""],["pid_type_PIDTYPE_MAX",""],["pid_type_PIDTYPE_PGID",""],["pid_type_PIDTYPE_PID",""],["pid_type_PIDTYPE_SID",""],["pid_type___PIDTYPE_TGID",""],["probe_type_PROBE_DEFAULT_STRATEGY",""],["probe_type_PROBE_FORCE_SYNCHRONOUS",""],["probe_type_PROBE_PREFER_ASYNCHRONOUS",""],["quota_type_GRPQUOTA",""],["quota_type_PRJQUOTA",""],["quota_type_USRQUOTA",""],["rcu_sync_type_RCU_BH_SYNC",""],["rcu_sync_type_RCU_SCHED_SYNC",""],["rcu_sync_type_RCU_SYNC",""],["rpm_request_RPM_REQ_AUTOSUSPEND",""],["rpm_request_RPM_REQ_IDLE",""],["rpm_request_RPM_REQ_NONE",""],["rpm_request_RPM_REQ_RESUME",""],["rpm_request_RPM_REQ_SUSPEND",""],["rpm_status_RPM_ACTIVE",""],["rpm_status_RPM_RESUMING",""],["rpm_status_RPM_SUSPENDED",""],["rpm_status_RPM_SUSPENDING",""],["rw_hint_WRITE_LIFE_EXTREME",""],["rw_hint_WRITE_LIFE_LONG",""],["rw_hint_WRITE_LIFE_MEDIUM",""],["rw_hint_WRITE_LIFE_NONE",""],["rw_hint_WRITE_LIFE_NOT_SET",""],["rw_hint_WRITE_LIFE_SHORT",""],["rx_handler_result_RX_HANDLER_ANOTHER",""],["rx_handler_result_RX_HANDLER_CONSUMED",""],["rx_handler_result_RX_HANDLER_EXACT",""],["rx_handler_result_RX_HANDLER_PASS",""],["sk_action_SK_DROP",""],["sk_action_SK_PASS",""],["sk_pacing_SK_PACING_FQ",""],["sk_pacing_SK_PACING_NEEDED",""],["sk_pacing_SK_PACING_NONE",""],["socket_state_SS_CONNECTED",""],["socket_state_SS_CONNECTING",""],["socket_state_SS_DISCONNECTING",""],["socket_state_SS_FREE",""],["socket_state_SS_UNCONNECTED",""],["tc_setup_type_TC_SETUP_BLOCK",""],["tc_setup_type_TC_SETUP_CLSBPF",""],["tc_setup_type_TC_SETUP_CLSFLOWER",""],["tc_setup_type_TC_SETUP_CLSMATCHALL",""],["tc_setup_type_TC_SETUP_CLSU32",""],["tc_setup_type_TC_SETUP_QDISC_CBS",""],["tc_setup_type_TC_SETUP_QDISC_MQPRIO",""],["tc_setup_type_TC_SETUP_QDISC_PRIO",""],["tc_setup_type_TC_SETUP_QDISC_RED",""],["timespec_type_TT_COMPAT",""],["timespec_type_TT_NATIVE",""],["timespec_type_TT_NONE",""],["uprobe_task_state_UTASK_RUNNING",""],["uprobe_task_state_UTASK_SSTEP",""],["uprobe_task_state_UTASK_SSTEP_ACK",""],["uprobe_task_state_UTASK_SSTEP_TRAPPED",""],["vtime_state_VTIME_INACTIVE",""],["vtime_state_VTIME_SYS",""],["vtime_state_VTIME_USER",""],["wb_reason_WB_REASON_BACKGROUND",""],["wb_reason_WB_REASON_FORKER_THREAD",""],["wb_reason_WB_REASON_FREE_MORE_MEM",""],["wb_reason_WB_REASON_FS_FREE_SPACE",""],["wb_reason_WB_REASON_LAPTOP_TIMER",""],["wb_reason_WB_REASON_MAX",""],["wb_reason_WB_REASON_PERIODIC",""],["wb_reason_WB_REASON_SYNC",""],["wb_reason_WB_REASON_VMSCAN",""],["writeback_sync_modes_WB_SYNC_ALL",""],["writeback_sync_modes_WB_SYNC_NONE",""],["xdp_action_XDP_ABORTED",""],["xdp_action_XDP_DROP",""],["xdp_action_XDP_PASS",""],["xdp_action_XDP_REDIRECT",""],["xdp_action_XDP_TX",""],["zone_type_ZONE_DMA",""],["zone_type_ZONE_DMA32",""],["zone_type_ZONE_MOVABLE",""],["zone_type_ZONE_NORMAL",""],["zone_type___MAX_NR_ZONES",""]],"struct":[["Qdisc",""],["Qdisc_class_ops",""],["Qdisc_ops",""],["__BindgenBitfieldUnit",""],["__BindgenUnionField",""],["__IncompleteArrayField",""],["__sk_buff",""],["acpi_device_id",""],["address_space",""],["address_space_operations",""],["anon_vma",""],["arch_tlbflush_unmap_batch",""],["arch_uprobe_task",""],["assoc_array",""],["assoc_array_ptr",""],["atomic64_t",""],["atomic_t",""],["attribute",""],["attribute_group","struct attribute_group - data structure used to declare an attribute group. @name:\tOptional: Attribute group name \tIf specified, the attribute group will be created in \ta new subdirectory with this name. @is_visible:\tOptional: Function to return permissions associated with an \tattribute of the group. Will be called repeatedly for each \tnon-binary attribute in the group. Only read/write \tpermissions as well as SYSFS_PREALLOC are accepted. Must \treturn 0 if an attribute is not visible. The returned value \twill replace static permissions defined in struct attribute. @is_bin_visible: \tOptional: Function to return permissions associated with a \tbinary attribute of the group. Will be called repeatedly \tfor each binary attribute in the group. Only read/write \tpermissions as well as SYSFS_PREALLOC are accepted. Must \treturn 0 if a binary attribute is not visible. The returned \tvalue will replace static permissions defined in \tstruct bin_attribute. @attrs:\tPointer to NULL terminated list of attributes. @bin_attrs:\tPointer to NULL terminated list of binary attributes. \tEither attrs or bin_attrs or both must be provided."],["audit_context",""],["backing_dev_info",""],["bdi_writeback",""],["bdi_writeback_congested",""],["bin_attribute",""],["bio",""],["bio_integrity_payload",""],["bio_list",""],["bio_set",""],["bio_vec",""],["blk_plug",""],["block_device",""],["bpf_attr__bindgen_ty_1",""],["bpf_attr__bindgen_ty_2",""],["bpf_attr__bindgen_ty_3",""],["bpf_attr__bindgen_ty_4",""],["bpf_attr__bindgen_ty_5",""],["bpf_attr__bindgen_ty_6",""],["bpf_attr__bindgen_ty_7",""],["bpf_attr__bindgen_ty_8",""],["bpf_attr__bindgen_ty_9",""],["bpf_binary_header",""],["bpf_cgroup_dev_ctx",""],["bpf_fib_lookup",""],["bpf_insn",""],["bpf_lpm_trie_key",""],["bpf_map",""],["bpf_map_def",""],["bpf_map_info",""],["bpf_offloaded_map",""],["bpf_perf_event_data",""],["bpf_perf_event_value",""],["bpf_prog",""],["bpf_prog__bindgen_ty_1",""],["bpf_prog_array",""],["bpf_prog_aux",""],["bpf_prog_info",""],["bpf_prog_list",""],["bpf_prog_offload_ops",""],["bpf_skb_data_end",""],["bpf_sock",""],["bpf_sock_addr",""],["bpf_sock_ops",""],["bpf_sock_ops_kern",""],["bpf_sock_tuple",""],["bpf_spin_lock",""],["bpf_sysctl",""],["bpf_tcp_sock",""],["bpf_tunnel_key",""],["bpf_xfrm_state",""],["bug_entry",""],["bus_type","struct bus_type - The bus type of the device"],["bvec_iter",""],["callback_head","struct callback_head - callback structure for use with RCU and task_work @next: next update requests in a list @func: actual update function to call after the grace period."],["can_dev_rcv_lists",""],["cdev",""],["cee_pfc","struct cee_pfc - CEE PFC managed object"],["cee_pg","struct cee_pg - CEE Priority-Group managed object"],["cfs_rq",""],["cftype",""],["cgroup",""],["cgroup_bpf",""],["cgroup_cpu_stat",""],["cgroup_file",""],["cgroup_namespace",""],["cgroup_root",""],["cgroup_stat",""],["cgroup_subsys",""],["cgroup_subsys_state",""],["cgroup_taskset",""],["cisco_proto",""],["class","struct class - device classes @name:\tName of the class. @owner:\tThe module owner. @class_groups: Default attributes of this class. @dev_groups:\tDefault attributes of the devices that belong to the class. @dev_kobj:\tThe kobject that represents this class and links it into the hierarchy. @dev_uevent:\tCalled when a device is added, removed from this class, or a \tfew other things that generate uevents to add the environment \tvariables. @devnode:\tCallback to provide the devtmpfs. @class_release: Called to release this class. @dev_release: Called to release the device. @shutdown_pre: Called at shut-down time before driver shutdown. @ns_type:\tCallbacks so sysfs can detemine namespaces. @namespace:\tNamespace of the device belongs to this class. @pm:\t\tThe default device power management operations of this class. @p:\t\tThe private data of the driver core, no one other than the \tdriver core can touch this."],["compat_robust_list",""],["compat_robust_list_head",""],["compat_timespec",""],["completion",""],["core_state",""],["core_thread",""],["cpu_rmap",""],["cpumask",""],["cred",""],["css_set",""],["ct_pcpu",""],["ctl_dir",""],["ctl_node",""],["ctl_table",""],["ctl_table_header",""],["ctl_table_header__bindgen_ty_1__bindgen_ty_1",""],["ctl_table_poll",""],["ctl_table_root",""],["ctl_table_set",""],["dcb_app",""],["dcb_peer_app_info","struct dcb_peer_app_info - APP feature information sent by the peer"],["dcbnl_rtnl_ops",""],["delayed_call",""],["delayed_work",""],["dentry",""],["dentry_operations",""],["desc_struct",""],["dev_archdata",""],["dev_ifalias",""],["dev_links_info","struct dev_links_info - Device data related to device links. @suppliers: List of links to supplier devices. @consumers: List of links to consumer devices. @status: Driver status information."],["dev_pagemap","struct dev_pagemap - metadata for ZONE_DEVICE mappings @page_fault: callback when CPU fault on an unaddressable device page @page_free: free page callback when page refcount reaches 1 @altmap: pre-allocated/reserved memory for vmemmap allocations @res: physical address range covered by @ref @ref: reference count that pins the devm_memremap_pages() mapping @dev: host device of the mapping for debug @data: private data pointer for page_free() @type: memory type: see MEMORY_* in memory_hotplug.h"],["dev_pin_info",""],["dev_pm_domain","struct dev_pm_domain - power management domain representation."],["dev_pm_info",""],["dev_pm_ops","struct dev_pm_ops - device PM callbacks."],["dev_pm_qos",""],["device","struct device - The basic device structure @parent:\tThe device's \"parent\" device, the device to which it is attached. \t\tIn most cases, a parent device is some sort of bus or host \t\tcontroller. If parent is NULL, the device, is a top-level device, \t\twhich is not usually what you want. @p:\t\tHolds the private data of the driver core portions of the device. \t\tSee the comment of the struct device_private for detail. @kobj:\tA top-level, abstract class from which other classes are derived. @init_name:\tInitial name of the device. @type:\tThe type of device. \t\tThis identifies the device type and carries type-specific \t\tinformation. @mutex:\tMutex to synchronize calls to its driver. @bus:\tType of bus device is on. @driver:\tWhich driver has allocated this @platform_data: Platform data specific to the device. \t\tExample: For devices on custom boards, as typical of embedded \t\tand SOC based hardware, Linux often uses platform_data to point \t\tto board-specific structures describing devices and how they \t\tare wired.  That can include what ports are available, chip \t\tvariants, which GPIO pins act in what additional roles, and so \t\ton.  This shrinks the \"Board Support Packages\" (BSPs) and \t\tminimizes board-specific #ifdefs in drivers. @driver_data: Private pointer for driver specific info. @links:\tLinks to suppliers and consumers of this device. @power:\tFor device power management. \tSee Documentation/driver-api/pm/devices.rst for details. @pm_domain:\tProvide callbacks that are executed during system suspend, \t\thibernation, system resume and during runtime PM transitions \t\talong with subsystem-level and driver-level callbacks. @pins:\tFor device pin management. \tSee Documentation/driver-api/pinctl.rst for details. @msi_list:\tHosts MSI descriptors @msi_domain: The generic MSI domain this device is using. @numa_node:\tNUMA node this device is close to. @dma_ops:    DMA mapping operations for this device. @dma_mask:\tDma mask (if dma'ble device). @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all \t\thardware supports 64-bit addresses for consistent allocations \t\tsuch descriptors. @dma_pfn_offset: offset of DMA memory range relatively of RAM @dma_parms:\tA low level driver may set these to teach IOMMU code about \t\tsegment limitations. @dma_pools:\tDma pools (if dma'ble device). @dma_mem:\tInternal for coherent mem override. @cma_area:\tContiguous memory area for dma allocations @archdata:\tFor arch-specific additions. @of_node:\tAssociated device tree node. @fwnode:\tAssociated device node supplied by platform firmware. @devt:\tFor creating the sysfs \"dev\". @id:\t\tdevice instance @devres_lock: Spinlock to protect the resource of the device. @devres_head: The resources list of the device. @knode_class: The node used to add the device to the class list. @class:\tThe class of the device. @groups:\tOptional attribute groups. @release:\tCallback to free the device after all references have \t\tgone away. This should be set by the allocator of the \t\tdevice (i.e. the bus driver that discovered the device). @iommu_group: IOMMU group the device belongs to. @iommu_fwspec: IOMMU-specific properties supplied by firmware."],["device_dma_parameters",""],["device_driver","struct device_driver - The basic device driver structure @name:\tName of the device driver. @bus:\tThe bus which the device of this driver belongs to. @owner:\tThe module owner. @mod_name:\tUsed for built-in modules. @suppress_bind_attrs: Disables bind/unbind via sysfs. @probe_type:\tType of the probe (synchronous or asynchronous) to use. @of_match_table: The open firmware table. @acpi_match_table: The ACPI match table. @probe:\tCalled to query the existence of a specific device, \twhether this driver can work with it, and bind the driver \tto a specific device. @remove:\tCalled when the device is removed from the system to \tunbind a device from this driver. @shutdown:\tCalled at shut-down time to quiesce the device. @suspend:\tCalled to put the device to sleep mode. Usually to a \tlow power state. @resume:\tCalled to bring a device from sleep mode. @groups:\tDefault attributes that get created by the driver core \tautomatically. @pm:\t\tPower management operations of the device which matched \tthis driver. @p:\t\tDriver core's private data, no one other than the driver \tcore can touch this."],["device_node",""],["device_private",""],["device_type",""],["dir_context",""],["dma_coherent_mem",""],["dma_map_ops",""],["dn_dev",""],["dql",""],["dquot",""],["dquot_operations",""],["driver_private",""],["dst_entry",""],["dst_ops",""],["ebt_table",""],["elf64_sym",""],["error_injection_entry",""],["ethhdr",""],["ethtool_ah_espip4_spec","struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4 @ip4src: Source host @ip4dst: Destination host @spi: Security parameters index @tos: Type-of-service"],["ethtool_ah_espip6_spec","struct ethtool_ah_espip6_spec - flow specification for IPsec/IPv6 @ip6src: Source host @ip6dst: Destination host @spi: Security parameters index @tclass: Traffic Class"],["ethtool_channels","struct ethtool_channels - configuring number of network channel @cmd: ETHTOOL_{G,S}CHANNELS @max_rx: Read only. Maximum number of receive channel the driver support. @max_tx: Read only. Maximum number of transmit channel the driver support. @max_other: Read only. Maximum number of other channel the driver support. @max_combined: Read only. Maximum number of combined channel the driver support. Set of queues RX, TX or other. @rx_count: Valid values are in the range 1 to the max_rx. @tx_count: Valid values are in the range 1 to the max_tx. @other_count: Valid values are in the range 1 to the max_other. @combined_count: Valid values are in the range 1 to the max_combined."],["ethtool_cmd","struct ethtool_cmd - DEPRECATED, link control and status This structure is DEPRECATED, please use struct ethtool_link_settings. @cmd: Command number = %ETHTOOL_GSET or %ETHTOOL_SSET @supported: Bitmask of %SUPPORTED_* flags for the link modes, physical connectors and other link features for which the interface supports autonegotiation or auto-detection. Read-only. @advertising: Bitmask of %ADVERTISED_* flags for the link modes, physical connectors and other link features that are advertised through autonegotiation or enabled for auto-detection. @speed: Low bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN @duplex: Duplex mode; one of %DUPLEX_* @port: Physical connector type; one of %PORT_* @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not applicable.  For clause 45 PHYs this is the PRTAD. @transceiver: Historically used to distinguish different possible PHY types, but not in a consistent way.  Deprecated. @autoneg: Enable/disable autonegotiation and auto-detection; either %AUTONEG_DISABLE or %AUTONEG_ENABLE @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO protocols supported by the interface; 0 if unknown. Read-only. @maxtxpkt: Historically used to report TX IRQ coalescing; now obsoleted by &struct ethtool_coalesce.  Read-only; deprecated. @maxrxpkt: Historically used to report RX IRQ coalescing; now obsoleted by &struct ethtool_coalesce.  Read-only; deprecated. @speed_hi: High bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of %ETH_TP_MDI_.  If the status is unknown or not applicable, the value will be %ETH_TP_MDI_INVALID.  Read-only. @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of %ETH_TP_MDI_.  If MDI(-X) control is not implemented, reads yield %ETH_TP_MDI_INVALID and writes may be ignored or rejected. When written successfully, the link should be renegotiated if necessary. @lp_advertising: Bitmask of %ADVERTISED_* flags for the link modes and other link features that the link partner advertised through autonegotiation; 0 if unknown or not applicable. Read-only."],["ethtool_coalesce","struct ethtool_coalesce - coalescing parameters for IRQs and stats updates @cmd: ETHTOOL_{G,S}COALESCE @rx_coalesce_usecs: How many usecs to delay an RX interrupt after a packet arrives. @rx_max_coalesced_frames: Maximum number of packets to receive before an RX interrupt. @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that this value applies while an IRQ is being serviced by the host. @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames, except that this value applies while an IRQ is being serviced by the host. @tx_coalesce_usecs: How many usecs to delay a TX interrupt after a packet is sent. @tx_max_coalesced_frames: Maximum number of packets to be sent before a TX interrupt. @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that this value applies while an IRQ is being serviced by the host. @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames, except that this value applies while an IRQ is being serviced by the host. @stats_block_coalesce_usecs: How many usecs to delay in-memory statistics block updates.  Some drivers do not have an in-memory statistic block, and in such cases this value is ignored.  This value must not be zero. @use_adaptive_rx_coalesce: Enable adaptive RX coalescing. @use_adaptive_tx_coalesce: Enable adaptive TX coalescing. @pkt_rate_low: Threshold for low packet rate (packets per second). @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after a packet arrives, when the packet rate is below @pkt_rate_low. @rx_max_coalesced_frames_low: Maximum number of packets to be received before an RX interrupt, when the packet rate is below @pkt_rate_low. @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after a packet is sent, when the packet rate is below @pkt_rate_low. @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before a TX interrupt, when the packet rate is below @pkt_rate_low. @pkt_rate_high: Threshold for high packet rate (packets per second). @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after a packet arrives, when the packet rate is above @pkt_rate_high. @rx_max_coalesced_frames_high: Maximum number of packets to be received before an RX interrupt, when the packet rate is above @pkt_rate_high. @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after a packet is sent, when the packet rate is above @pkt_rate_high. @tx_max_coalesced_frames_high: Maximum number of packets to be sent before a TX interrupt, when the packet rate is above @pkt_rate_high. @rate_sample_interval: How often to do adaptive coalescing packet rate sampling, measured in seconds.  Must not be zero."],["ethtool_drvinfo","struct ethtool_drvinfo - general driver and device information @cmd: Command number = %ETHTOOL_GDRVINFO @driver: Driver short name.  This should normally match the name in its bus driver structure (e.g. pci_driver::name).  Must not be an empty string. @version: Driver version string; may be an empty string @fw_version: Firmware version string; may be an empty string @erom_version: Expansion ROM version string; may be an empty string @bus_info: Device bus address.  This should match the dev_name() string for the underlying bus device, if there is one.  May be an empty string. @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS commands; also the number of strings in the %ETH_SS_PRIV_FLAGS set @n_stats: Number of u64 statistics returned by the %ETHTOOL_GSTATS command; also the number of strings in the %ETH_SS_STATS set @testinfo_len: Number of results returned by the %ETHTOOL_TEST command; also the number of strings in the %ETH_SS_TEST set @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM and %ETHTOOL_SEEPROM commands, in bytes @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS command, in bytes"],["ethtool_dump","struct ethtool_dump - used for retrieving, setting device dump @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or \t%ETHTOOL_SET_DUMP @version: FW version of the dump, filled in by driver @flag: driver dependent flag for dump setting, filled in by driver during        get and filled in by ethtool for set operation.        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when        firmware dump is disabled. @len: length of dump data, used as the length of the user buffer on entry to \t %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver \t for %ETHTOOL_GET_DUMP_FLAG command @data: data collected for get dump data operation"],["ethtool_eee","struct ethtool_eee - Energy Efficient Ethernet information @cmd: ETHTOOL_{G,S}EEE @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations for which there is EEE support. @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations advertised as eee capable. @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations advertised by the link partner as eee capable. @eee_active: Result of the eee auto negotiation. @eee_enabled: EEE configured mode (enabled/disabled). @tx_lpi_enabled: Whether the interface should assert its tx lpi, given that eee was negotiated. @tx_lpi_timer: Time in microseconds the interface delays prior to asserting its tx lpi (after reaching 'idle' state). Effective only when eee was negotiated and tx_lpi_enabled was set."],["ethtool_eeprom","struct ethtool_eeprom - EEPROM dump @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or %ETHTOOL_SEEPROM @magic: A 'magic cookie' value to guard against accidental changes. The value passed in to %ETHTOOL_SEEPROM must match the value returned by %ETHTOOL_GEEPROM for the same device.  This is unused when @cmd is %ETHTOOL_GMODULEEEPROM. @offset: Offset within the EEPROM to begin reading/writing, in bytes @len: On entry, number of bytes to read/write.  On successful return, number of bytes actually read/written.  In case of error, this may indicate at what point the error occurred. @data: Buffer to read/write from"],["ethtool_fecparam","struct ethtool_fecparam - Ethernet forward error correction(fec) parameters @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM @active_fec: FEC mode which is active on porte @fec: Bitmask of supported/configured FEC modes @rsvd: Reserved for future extensions. i.e FEC bypass feature."],["ethtool_flash",""],["ethtool_flow_ext","struct ethtool_flow_ext - additional RX flow fields @h_dest: destination MAC address @vlan_etype: VLAN EtherType @vlan_tci: VLAN tag control information @data: user defined data"],["ethtool_link_ksettings",""],["ethtool_link_ksettings__bindgen_ty_1",""],["ethtool_link_settings","struct ethtool_link_settings - link control and status"],["ethtool_modinfo","struct ethtool_modinfo - plugin module eeprom information @cmd: %ETHTOOL_GMODULEINFO @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx @eeprom_len: Length of the eeprom"],["ethtool_ops","struct ethtool_ops - optional netdev operations @get_settings: DEPRECATED, use %get_link_ksettings/%set_link_ksettings API. Get various device settings including Ethernet link settings. The @cmd parameter is expected to have been cleared before get_settings is called. Returns a negative error code or zero. @set_settings: DEPRECATED, use %get_link_ksettings/%set_link_ksettings API. Set various device settings including Ethernet link settings.  Returns a negative error code or zero. @get_drvinfo: Report driver/device information.  Should only set the @driver, @version, @fw_version and @bus_info fields.  If not implemented, the @driver and @bus_info fields will be filled in according to the netdev's parent device. @get_regs_len: Get buffer length required for @get_regs @get_regs: Get device registers @get_wol: Report whether Wake-on-Lan is enabled @set_wol: Turn Wake-on-Lan on or off.  Returns a negative error code or zero. @get_msglevel: Report driver message level.  This should be the value of the @msg_enable field used by netif logging functions. @set_msglevel: Set driver message level @nway_reset: Restart autonegotiation.  Returns a negative error code or zero. @get_link: Report whether physical link is up.  Will only be called if the netdev is up.  Should usually be set to ethtool_op_get_link(), which uses netif_carrier_ok(). @get_eeprom: Read data from the device EEPROM. Should fill in the magic field.  Don't need to check len for zero or wraparound.  Fill in the data argument with the eeprom values from offset to offset + len.  Update len to the amount read. Returns an error or zero. @set_eeprom: Write data to the device EEPROM. Should validate the magic field.  Don't need to check len for zero or wraparound.  Update len to the amount written.  Returns an error or zero. @get_coalesce: Get interrupt coalescing parameters.  Returns a negative error code or zero. @set_coalesce: Set interrupt coalescing parameters.  Returns a negative error code or zero. @get_ringparam: Report ring sizes @set_ringparam: Set ring sizes.  Returns a negative error code or zero. @get_pauseparam: Report pause parameters @set_pauseparam: Set pause parameters.  Returns a negative error code or zero. @self_test: Run specified self-tests @get_strings: Return a set of strings that describe the requested objects @set_phys_id: Identify the physical devices, e.g. by flashing an LED attached to it.  The implementation may update the indicator asynchronously or synchronously, but in either case it must return quickly.  It is initially called with the argument %ETHTOOL_ID_ACTIVE, and must either activate asynchronous updates and return zero, return a negative error or return a positive frequency for synchronous indication (e.g. 1 for one on/off cycle per second).  If it returns a frequency then it will be called again at intervals with the argument %ETHTOOL_ID_ON or %ETHTOOL_ID_OFF and should set the state of the indicator accordingly.  Finally, it is called with the argument %ETHTOOL_ID_INACTIVE and must deactivate the indicator.  Returns a negative error code or zero. @get_ethtool_stats: Return extended statistics about the device. This is only useful if the device maintains statistics not included in &struct rtnl_link_stats64. @begin: Function to be called before any other operation.  Returns a negative error code or zero. @complete: Function to be called after any other operation except @begin.  Will be called even if the other operation failed. @get_priv_flags: Report driver-specific feature flags. @set_priv_flags: Set driver-specific feature flags.  Returns a negative error code or zero. @get_sset_count: Get number of strings that @get_strings will write. @get_rxnfc: Get RX flow classification rules.  Returns a negative error code or zero. @set_rxnfc: Set RX flow classification rules.  Returns a negative error code or zero. @flash_device: Write a firmware image to device's flash memory. Returns a negative error code or zero. @reset: Reset (part of) the device, as specified by a bitmask of flags from &enum ethtool_reset_flags.  Returns a negative error code or zero. @get_rxfh_key_size: Get the size of the RX flow hash key. Returns zero if not supported for this specific device. @get_rxfh_indir_size: Get the size of the RX flow hash indirection table. Returns zero if not supported for this specific device. @get_rxfh: Get the contents of the RX flow hash indirection table, hash key and/or hash function. Returns a negative error code or zero. @set_rxfh: Set the contents of the RX flow hash indirection table, hash key, and/or hash function.  Arguments which are set to %NULL or zero will remain unchanged. Returns a negative error code or zero. An error code must be returned if at least one unsupported change was requested. @get_channels: Get number of channels. @set_channels: Set number of channels.  Returns a negative error code or zero. @get_dump_flag: Get dump flag indicating current dump length, version, \t\t   and flag of the device. @get_dump_data: Get dump data. @set_dump: Set dump specific flags to the device. @get_ts_info: Get the time stamping and PTP hardware clock capabilities. Drivers supporting transmit time stamps in software should set this to ethtool_op_get_ts_info(). @get_module_info: Get the size and type of the eeprom contained within a plug-in module. @get_module_eeprom: Get the eeprom information from the plug-in module @get_eee: Get Energy-Efficient (EEE) supported and status. @set_eee: Set EEE status (enable/disable) as well as LPI timers. @get_per_queue_coalesce: Get interrupt coalescing parameters per queue. It must check that the given queue number is valid. If neither a RX nor a TX queue has this number, return -EINVAL. If only a RX queue or a TX queue has this number, set the inapplicable fields to ~0 and return 0. Returns a negative error code or zero. @set_per_queue_coalesce: Set interrupt coalescing parameters per queue. It must check that the given queue number is valid. If neither a RX nor a TX queue has this number, return -EINVAL. If only a RX queue or a TX queue has this number, ignore the inapplicable fields. Returns a negative error code or zero. @get_link_ksettings: When defined, takes precedence over the %get_settings method. Get various device settings including Ethernet link settings. The %cmd and %link_mode_masks_nwords fields should be ignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter), any change to them will be overwritten by kernel. Returns a negative error code or zero. @set_link_ksettings: When defined, takes precedence over the %set_settings method. Set various device settings including Ethernet link settings. The %cmd and %link_mode_masks_nwords fields should be ignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter), any change to them will be overwritten by kernel. Returns a negative error code or zero."],["ethtool_pauseparam","struct ethtool_pauseparam - Ethernet pause (flow control) parameters @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM @autoneg: Flag to enable autonegotiation of pause frame use @rx_pause: Flag to enable reception of pause frames @tx_pause: Flag to enable transmission of pause frames"],["ethtool_regs","struct ethtool_regs - hardware register dump @cmd: Command number = %ETHTOOL_GREGS @version: Dump format version.  This is driver-specific and may distinguish different chips/revisions.  Drivers must use new version numbers whenever the dump format changes in an incompatible way. @len: On entry, the real length of @data.  On return, the number of bytes used. @data: Buffer for the register dump"],["ethtool_ringparam","struct ethtool_ringparam - RX/TX ring parameters @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM @rx_max_pending: Maximum supported number of pending entries per RX ring.  Read-only. @rx_mini_max_pending: Maximum supported number of pending entries per RX mini ring.  Read-only. @rx_jumbo_max_pending: Maximum supported number of pending entries per RX jumbo ring.  Read-only. @tx_max_pending: Maximum supported number of pending entries per TX ring.  Read-only. @rx_pending: Current maximum number of pending entries per RX ring @rx_mini_pending: Current maximum number of pending entries per RX mini ring @rx_jumbo_pending: Current maximum number of pending entries per RX jumbo ring @tx_pending: Current maximum supported number of pending entries per TX ring"],["ethtool_rx_flow_spec","struct ethtool_rx_flow_spec - classification rule for RX flows @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW @h_u: Flow fields to match (dependent on @flow_type) @h_ext: Additional fields to match @m_u: Masks for flow field bits to be matched @m_ext: Masks for additional field bits to be matched Note, all additional fields must be ignored unless @flow_type includes the %FLOW_EXT or %FLOW_MAC_EXT flag (see &struct ethtool_flow_ext description). @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC if packets should be discarded @location: Location of rule in the table.  Locations must be numbered such that a flow matching multiple rules will be classified according to the first (lowest numbered) rule."],["ethtool_rxnfc","struct ethtool_rxnfc - command to get or set RX flow classification rules @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH, %ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE, %ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW @data: Command-dependent value @fs: Flow classification rule @rule_cnt: Number of rules to be affected @rule_locs: Array of used rule locations"],["ethtool_stats","struct ethtool_stats - device-specific statistics @cmd: Command number = %ETHTOOL_GSTATS @n_stats: On return, the number of statistics @data: Array of statistics"],["ethtool_tcpip4_spec","struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc. @ip4src: Source host @ip4dst: Destination host @psrc: Source port @pdst: Destination port @tos: Type-of-service"],["ethtool_tcpip6_spec","struct ethtool_tcpip6_spec - flow specification for TCP/IPv6 etc. @ip6src: Source host @ip6dst: Destination host @psrc: Source port @pdst: Destination port @tclass: Traffic Class"],["ethtool_test","struct ethtool_test - device self-test invocation @cmd: Command number = %ETHTOOL_TEST @flags: A bitmask of flags from &enum ethtool_test_flags.  Some flags may be set by the user on entry; others may be set by the driver on return. @len: On return, the number of test results @data: Array of test results"],["ethtool_ts_info","struct ethtool_ts_info - holds a device's timestamping and PHC association @cmd: command number = %ETHTOOL_GET_TS_INFO @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags @phc_index: device index of the associated PHC, or -1 if there is none @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values"],["ethtool_tunable",""],["ethtool_usrip4_spec","struct ethtool_usrip4_spec - general flow specification for IPv4 @ip4src: Source host @ip4dst: Destination host @l4_4_bytes: First 4 bytes of transport (layer 4) header @tos: Type-of-service @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0 @proto: Transport protocol number; mask must be 0"],["ethtool_usrip6_spec","struct ethtool_usrip6_spec - general flow specification for IPv6 @ip6src: Source host @ip6dst: Destination host @l4_4_bytes: First 4 bytes of transport (layer 4) header @tclass: Traffic Class @l4_proto: Transport protocol number (nexthdr after any Extension Headers)"],["ethtool_wolinfo","struct ethtool_wolinfo - Wake-On-Lan configuration @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes. Read-only. @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes. @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE is set in @wolopts."],["eventfd_ctx",""],["exception_table_entry",""],["export_operations",""],["fasync_struct",""],["fib6_table",""],["fib_kuid_range",""],["fib_lookup_arg",""],["fib_notifier_ops",""],["fib_rule",""],["fib_rule_hdr",""],["fib_rules_ops",""],["fib_table",""],["fiemap_extent",""],["fiemap_extent_info",""],["file",""],["file_lock",""],["file_lock__bindgen_ty_1__bindgen_ty_1",""],["file_lock_context",""],["file_lock_operations",""],["file_operations",""],["file_ra_state",""],["file_system_type",""],["files_struct",""],["flowi",""],["flowi4",""],["flowi6",""],["flowi_common",""],["flowi_tunnel",""],["flowi_uli__bindgen_ty_1",""],["flowi_uli__bindgen_ty_2",""],["flowi_uli__bindgen_ty_3",""],["flowi_uli__bindgen_ty_4",""],["flowidn",""],["fown_struct",""],["fpregs_state",""],["fprop_global",""],["fprop_local_percpu",""],["fpu",""],["fr_proto",""],["fr_proto_pvc",""],["fr_proto_pvc_info",""],["free_area",""],["fregs_state",""],["fs_struct",""],["fscrypt_operations",""],["fsnotify_mark_connector",""],["ftrace_ret_stack",""],["futex_pi_state",""],["fwnode_handle",""],["fxregs_state",""],["fxregs_state__bindgen_ty_1__bindgen_ty_1",""],["fxregs_state__bindgen_ty_1__bindgen_ty_2",""],["garp_port",""],["gendisk",""],["gnet_dump",""],["gnet_stats_basic_cpu",""],["gnet_stats_basic_packed",""],["gnet_stats_queue","struct gnet_stats_queue - queuing statistics @qlen: queue length @backlog: backlog size of queue @drops: number of dropped packets @requeues: number of requeues @overlimits: number of enqueues over the limit"],["group_info",""],["hd_struct",""],["header_ops",""],["hh_cache",""],["hlist_bl_head",""],["hlist_bl_node",""],["hlist_head",""],["hlist_node",""],["hlist_nulls_head",""],["hlist_nulls_node",""],["hrtimer","struct hrtimer - the basic hrtimer structure @node:\ttimerqueue node, which also manages node.expires, \tthe absolute expiry time in the hrtimers internal \trepresentation. The time is related to the clock on \twhich the timer is based. Is setup by adding \tslack to the _softexpires value. For non range timers \tidentical to _softexpires. @_softexpires: the absolute earliest expiry time of the hrtimer. \tThe time which was given as expiry time when the timer \twas armed. @function:\ttimer expiry callback function @base:\tpointer to the timer base (per cpu and per clock) @state:\tstate information (See bit values above) @is_rel:\tSet if the timer was armed relative @is_soft:\tSet if hrtimer will be expired in soft interrupt context."],["hrtimer_clock_base","struct hrtimer_clock_base - the timer base for a specific clock @cpu_base:\t\tper cpu clock base @index:\t\tclock type index for per_cpu support when moving a \t\ttimer to a base on another cpu. @clockid:\t\tclock id for per_cpu support @seq:\t\tseqcount around __run_hrtimer @running:\t\tpointer to the currently running hrtimer @active:\t\tred black tree root node for the active timers @get_time:\t\tfunction to retrieve the current time of the clock @offset:\t\toffset of this clock to the monotonic base"],["hrtimer_cpu_base","struct hrtimer_cpu_base - the per cpu clock bases @lock:\t\tlock protecting the base and associated clock bases \t\tand timers @cpu:\t\tcpu number @active_bases:\tBitfield to mark bases with active timers @clock_was_set_seq:\tSequence counter of clock was set events @hres_active:\tState of high resolution mode @in_hrtirq:\t\thrtimer_interrupt() is currently executing @hang_detected:\tThe last hrtimer interrupt detected a hang @softirq_activated:\tdisplays, if the softirq is raised - update of softirq \t\trelated settings is not required then. @nr_events:\t\tTotal number of hrtimer interrupt events @nr_retries:\t\tTotal number of hrtimer interrupt retries @nr_hangs:\t\tTotal number of hrtimer interrupt hangs @max_hang_time:\tMaximum time spent in hrtimer_interrupt @expires_next:\tabsolute time of the next event, is required for remote \t\thrtimer enqueue; it is the total first expiry time (hard \t\tand soft hrtimer are taken into account) @next_timer:\t\tPointer to the first expiring timer @softirq_expires_next: Time to check, if soft queues needs also to be expired @softirq_next_timer: Pointer to the first expiring softirq based timer @clock_base:\t\tarray of clock bases for this cpu"],["iattr",""],["icmp_mib",""],["icmpmsg_mib",""],["icmpv6_mib",""],["icmpv6msg_mib",""],["idr",""],["ieee_ets",""],["ieee_maxrate",""],["ieee_pfc",""],["ieee_qcn",""],["ieee_qcn_stats",""],["if_settings",""],["ifla_vf_info",""],["ifla_vf_stats",""],["ifmap",""],["ifreq",""],["in6_addr","csum_ipv6_magic - Compute checksum of an IPv6 pseudo header. @saddr: source address @daddr: destination address @len: length of packet @proto: protocol of packet @sum: initial sum (32bit unfolded) to be added in"],["in_device",""],["inet6_dev",""],["inet_cork",""],["inet_cork_full",""],["inet_hashinfo",""],["inet_peer_base",""],["inet_sock","struct inet_sock - representation of INET sockets"],["inet_timewait_death_row",""],["inode",""],["inode_operations",""],["io_context",""],["io_cq",""],["iommu_fwspec",""],["iommu_group",""],["iommu_ops",""],["iov_iter",""],["iov_iter__bindgen_ty_2__bindgen_ty_1",""],["iovec",""],["ip_conntrack_stat",""],["ip_mc_socklist",""],["ip_options","struct ip_options - IP Options"],["ip_options_rcu",""],["ipc_namespace",""],["iphdr",""],["ipstats_mib",""],["ipv4_devconf",""],["ipv6_devconf",""],["ipv6_pinfo",""],["irq_domain",""],["iw_handler_def",""],["iw_public_data",""],["kernel_cap_struct",""],["kernel_param",""],["kernel_param_ops",""],["kernel_symbol",""],["kernfs_elem_attr",""],["kernfs_elem_dir",""],["kernfs_elem_symlink",""],["kernfs_iattrs",""],["kernfs_node",""],["kernfs_node_id__bindgen_ty_1",""],["kernfs_open_file",""],["kernfs_open_node",""],["kernfs_ops",""],["kernfs_root",""],["kernfs_syscall_ops",""],["key",""],["key__bindgen_ty_3__bindgen_ty_1",""],["key__bindgen_ty_4__bindgen_ty_1",""],["key_restriction",""],["key_type",""],["key_user",""],["keyring_index_key",""],["kgid_t",""],["kiocb",""],["kioctx_table",""],["klist_node",""],["kmem_cache",""],["kobj_ns_type_operations",""],["kobj_type",""],["kobj_uevent_env",""],["kobject",""],["kparam_array",""],["kparam_string",""],["kprojid_t",""],["kqid",""],["kref",""],["kset","struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."],["kset_uevent_ops",""],["kstat",""],["kstatfs",""],["kuid_t",""],["kvec",""],["latch_tree_node",""],["ldt_struct",""],["linux_binfmt",""],["linux_mib",""],["linux_xfrm_mib",""],["list_head",""],["list_lru",""],["list_lru_memcg",""],["list_lru_node",""],["list_lru_one",""],["llist_node",""],["load_weight",""],["local_ports",""],["lock_class_key",""],["lock_manager_operations",""],["lockref",""],["lockref__bindgen_ty_1__bindgen_ty_1",""],["lruvec",""],["lruvec_stat",""],["lwtunnel_state",""],["math_emu_info",""],["mem_cgroup",""],["mem_cgroup_id",""],["mem_cgroup_per_node",""],["mem_cgroup_reclaim_iter",""],["mem_cgroup_stat_cpu",""],["mem_cgroup_threshold",""],["mem_cgroup_threshold_ary",""],["mem_cgroup_thresholds",""],["mem_dqblk",""],["mem_dqinfo",""],["mempolicy",""],["mempool_s",""],["mini_Qdisc",""],["mm_context_t",""],["mm_rss_stat",""],["mm_segment_t",""],["mm_struct",""],["mmu_notifier_mm",""],["mnt_namespace",""],["mod_arch_specific",""],["mod_kallsyms",""],["mod_tree_node",""],["module",""],["module_attribute",""],["module_kobject",""],["module_layout",""],["module_notes_attrs",""],["module_param_attrs",""],["module_sect_attrs",""],["mpls_dev",""],["mpls_route",""],["mrp_port",""],["msghdr",""],["mtd_info",""],["mutex",""],["nameidata",""],["ndisc_ops",""],["ndmsg",""],["neigh_hash_table",""],["neigh_ops",""],["neigh_parms",""],["neigh_statistics",""],["neigh_table",""],["neighbour",""],["net",""],["net_device","struct net_device - The DEVICE structure."],["net_device__bindgen_ty_1",""],["net_device_ops",""],["net_device_stats",""],["net_generic",""],["net_rate_estimator",""],["netdev_bpf",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_1",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_2",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_3",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_4",""],["netdev_bpf__bindgen_ty_1__bindgen_ty_5",""],["netdev_fcoe_hbainfo",""],["netdev_hw_addr_list",""],["netdev_phys_item_id",""],["netdev_queue",""],["netdev_rx_queue",""],["netdev_tc_txq",""],["netlink_callback",""],["netlink_ext_ack","struct netlink_ext_ack - netlink extended ACK report struct @_msg: message string to report - don't access directly, use %NL_SET_ERR_MSG @bad_attr: attribute with error @cookie: cookie data to return to userspace (for success) @cookie_len: actual cookie data length"],["netns_can",""],["netns_core",""],["netns_ct",""],["netns_dccp",""],["netns_frags",""],["netns_ipv4",""],["netns_ipv6",""],["netns_ipv6__bindgen_ty_1",""],["netns_ipvs",""],["netns_mib",""],["netns_mpls",""],["netns_nf",""],["netns_nf_frag",""],["netns_nftables",""],["netns_packet",""],["netns_sctp",""],["netns_sysctl_ipv6",""],["netns_unix",""],["netns_xfrm",""],["netns_xt",""],["netpoll_info",""],["netprio_map",""],["nf_bridge_info",""],["nf_ct_event_notifier",""],["nf_dccp_net",""],["nf_exp_event_notifier",""],["nf_generic_net",""],["nf_hook_entries",""],["nf_icmp_net",""],["nf_ip_net",""],["nf_logger",""],["nf_proto_net",""],["nf_queue_handler",""],["nf_sctp_net",""],["nf_tcp_net",""],["nf_udp_net",""],["nfs4_lock_info",""],["nfs4_lock_state",""],["nfs_lock_info",""],["nla_policy","struct nla_policy - attribute validation policy @type: Type of attribute or NLA_UNSPEC @len: Type specific length of payload"],["nlattr",""],["nlm_lockowner",""],["nlmsghdr",""],["nodemask_t",""],["notifier_block",""],["ns_common",""],["nsproxy",""],["numa_group",""],["of_device_id",""],["optimistic_spin_queue",""],["page",""],["page__bindgen_ty_3__bindgen_ty_1",""],["page__bindgen_ty_3__bindgen_ty_2",""],["page__bindgen_ty_4__bindgen_ty_1",""],["page__bindgen_ty_4__bindgen_ty_2",""],["page__bindgen_ty_4__bindgen_ty_3",""],["page_counter",""],["page_frag",""],["path",""],["pcpu_dstats",""],["pcpu_lstats",""],["pcpu_sw_netstats",""],["pcpu_vstats",""],["per_cpu_nodestat",""],["per_cpu_pages",""],["per_cpu_pageset",""],["percpu_counter",""],["percpu_ref",""],["percpu_rw_semaphore",""],["perf_event",""],["perf_event_context",""],["pgd_t",""],["pglist_data",""],["pgprot",""],["phy_device",""],["pid",""],["pid_link",""],["pid_namespace",""],["ping_group_range",""],["pipe_buf_operations",""],["pipe_buffer","struct pipe_buffer - a linux kernel pipe buffer @page: the page containing the data for the pipe buffer @offset: offset of data inside the @page @len: length of data inside the @page @ops: operations associated with this buffer. See @pipe_buf_operations. @flags: pipe buffer flags. See above. @private: private data owned by the ops."],["pipe_inode_info","struct pipe_inode_info - a linux kernel pipe @mutex: mutex protecting the whole thing @wait: reader/writer wait point in case of empty/full pipe @nrbufs: the number of non-empty pipe buffers in this pipe @buffers: total number of buffers (should be a power of 2) @curbuf: the current pipe buffer entry @tmp_page: cached released page @readers: number of current readers of this pipe @writers: number of current writers of this pipe @files: number of struct file referring this pipe (protected by ->i_lock) @waiting_writers: number of writers blocked waiting for room @r_counter: reader counter @w_counter: writer counter @fasync_readers: reader side fasync @fasync_writers: writer side fasync @bufs: the circular array of pipe buffers @user: the user who created this pipe"],["plist_node",""],["pm_message",""],["pm_subsys_data",""],["pmd_t",""],["pneigh_entry",""],["poll_table_struct",""],["pollfd",""],["posix_acl",""],["possible_net_t",""],["prev_cputime","struct prev_cputime - snapshot of system and user cputime @utime: time spent in user mode @stime: time spent in system mode @lock: protects the above two fields"],["proc_dir_entry",""],["proc_ns_operations",""],["prot_inuse",""],["proto",""],["proto_ops",""],["pt_regs",""],["pte_t",""],["pud_t",""],["qc_dqblk",""],["qc_info",""],["qc_state",""],["qc_type_state",""],["qdisc_size_table",""],["qdisc_skb_cb",""],["qdisc_skb_head",""],["qdisc_walker",""],["qrwlock",""],["qrwlock__bindgen_ty_1__bindgen_ty_1",""],["qspinlock",""],["qstr",""],["qstr__bindgen_ty_1__bindgen_ty_1",""],["quota_format_ops",""],["quota_format_type",""],["quota_info",""],["quotactl_ops",""],["radix_tree_node",""],["radix_tree_root",""],["ratelimit_state",""],["raw_hashinfo",""],["raw_hdlc_proto",""],["raw_spinlock",""],["rb_node",""],["rb_root",""],["rb_root_cached",""],["rcu_sync",""],["rcuwait",""],["read_descriptor_t",""],["reclaim_state",""],["refcount_struct","struct refcount_t - variant of atomic_t specialized for reference counts @refs: atomic_t counter field"],["request_queue",""],["request_sock",""],["request_sock_ops",""],["resource",""],["restart_block",""],["restart_block__bindgen_ty_1__bindgen_ty_1",""],["restart_block__bindgen_ty_1__bindgen_ty_2",""],["restart_block__bindgen_ty_1__bindgen_ty_3",""],["return_instance",""],["robust_list_head",""],["rps_dev_flow",""],["rps_dev_flow_table",""],["rps_map",""],["rt6_info",""],["rt6_statistics",""],["rt_mutex_waiter",""],["rt_rq",""],["rtnl_link_ops","struct rtnl_link_ops - rtnetlink link operations"],["rtnl_link_stats64",""],["rw_semaphore",""],["rwlock_t",""],["s_pstats",""],["s_stats",""],["sb_writers",""],["scatterlist",""],["sched_avg",""],["sched_class",""],["sched_dl_entity",""],["sched_entity",""],["sched_info",""],["sched_rt_entity",""],["sched_statistics",""],["sctp_mib",""],["sec_path",""],["seccomp","struct seccomp - the state of a seccomp'ed process"],["seccomp_filter",""],["seg6_pernet_data",""],["sem_undo_list",""],["seq_file",""],["seq_operations",""],["seqcount",""],["seqlock_t",""],["sg_table",""],["shrink_control",""],["shrinker",""],["sighand_struct",""],["siginfo",""],["siginfo__bindgen_ty_1__bindgen_ty_1",""],["siginfo__bindgen_ty_1__bindgen_ty_2",""],["siginfo__bindgen_ty_1__bindgen_ty_3",""],["siginfo__bindgen_ty_1__bindgen_ty_4",""],["siginfo__bindgen_ty_1__bindgen_ty_5",""],["siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1",""],["siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2",""],["siginfo__bindgen_ty_1__bindgen_ty_6",""],["siginfo__bindgen_ty_1__bindgen_ty_7",""],["signal_struct",""],["sigpending",""],["sigset_t",""],["sk_buff","struct sk_buff - socket buffer @next: Next buffer in list @prev: Previous buffer in list @tstamp: Time we arrived/left @rbnode: RB tree node, alternative to next/prev for netem/tcp @sk: Socket we are owned by @dev: Device we arrived on/are leaving by @cb: Control buffer. Free for use by every layer. Put private vars here @_skb_refdst: destination entry (with norefcount bit) @sp: the security path, used for xfrm @len: Length of actual data @data_len: Data length @mac_len: Length of link layer header @hdr_len: writable header length of cloned skb @csum: Checksum (must include start/offset pair) @csum_start: Offset from skb->head where checksumming should start @csum_offset: Offset from csum_start where checksum should be stored @priority: Packet queueing priority @ignore_df: allow local fragmentation @cloned: Head may be cloned (check refcnt to be sure) @ip_summed: Driver fed us an IP checksum @nohdr: Payload reference only, must not modify header @pkt_type: Packet class @fclone: skbuff clone status @ipvs_property: skbuff is owned by ipvs @tc_skip_classify: do not classify packet. set by IFB device @tc_at_ingress: used within tc_classify to distinguish in/egress @tc_redirected: packet was redirected by a tc action @tc_from_ingress: if tc_redirected, tc_at_ingress at time of redirect @peeked: this packet has been seen already, so stats have been \tdone for it, don't do them again @nf_trace: netfilter packet trace flag @protocol: Packet protocol from driver @destructor: Destruct function @tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue) @_nfct: Associated connection, if any (with nfctinfo bits) @nf_bridge: Saved data about a bridged frame - see br_netfilter.c @skb_iif: ifindex of device we arrived on @tc_index: Traffic control index @hash: the packet hash @queue_mapping: Queue mapping for multiqueue devices @xmit_more: More SKBs are pending for this queue @ndisc_nodetype: router type (from link layer) @ooo_okay: allow the mapping of a socket to a queue to be changed @l4_hash: indicate hash is a canonical 4-tuple hash over transport \tports. @sw_hash: indicates hash was computed in software stack @wifi_acked_valid: wifi_acked was set @wifi_acked: whether frame was acked on wifi or not @no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS @csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL @dst_pending_confirm: need to confirm neighbour @napi_id: id of the NAPI struct this skb came from @secmark: security marking @mark: Generic packet mark @vlan_proto: vlan encapsulation protocol @vlan_tci: vlan tag control information @inner_protocol: Protocol (encapsulation) @inner_transport_header: Inner transport layer header (encapsulation) @inner_network_header: Network layer header (encapsulation) @inner_mac_header: Link layer header (encapsulation) @transport_header: Transport layer header @network_header: Network layer header @mac_header: Link layer header @tail: Tail pointer @end: End pointer @head: Head of buffer @data: Data head pointer @truesize: Buffer size @users: User count - see {datagram,tcp}.c"],["sk_buff__bindgen_ty_1__bindgen_ty_1",""],["sk_buff__bindgen_ty_3__bindgen_ty_1",""],["sk_buff__bindgen_ty_4__bindgen_ty_1",""],["sk_buff_fclones",""],["sk_buff_head",""],["sk_filter",""],["sk_msg_md",""],["sk_reuseport_md",""],["smc_hashinfo",""],["sock","struct sock - network layer representation of sockets @__sk_common: shared layout with inet_timewait_sock @sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN @sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings @sk_lock:\tsynchronizer @sk_kern_sock: True if sock is using kernel lock classes @sk_rcvbuf: size of receive buffer in bytes @sk_wq: sock wait queue and async head @sk_rx_dst: receive input route used by early demux @sk_dst_cache: destination cache @sk_dst_pending_confirm: need to confirm neighbour @sk_policy: flow policy @sk_receive_queue: incoming packets @sk_wmem_alloc: transmit queue bytes committed @sk_tsq_flags: TCP Small Queues flags @sk_write_queue: Packet sending queue @sk_omem_alloc: \"o\" is \"option\" or \"other\" @sk_wmem_queued: persistent queue size @sk_forward_alloc: space allocated forward @sk_napi_id: id of the last napi context to receive data for sk @sk_ll_usec: usecs to busypoll when there is no data @sk_allocation: allocation mode @sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler) @sk_pacing_status: Pacing status (requested, handled by sch_fq) @sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE) @sk_sndbuf: size of send buffer in bytes @__sk_flags_offset: empty field used to determine location of bitfield @sk_padding: unused element for alignment @sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets @sk_no_check_rx: allow zero checksum in RX packets @sk_route_caps: route capabilities (e.g. %NETIF_F_TSO) @sk_route_nocaps: forbidden route capabilities (e.g NETIF_F_GSO_MASK) @sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4) @sk_gso_max_size: Maximum GSO segment size to build @sk_gso_max_segs: Maximum number of GSO segments @sk_pacing_shift: scaling factor for TCP Small Queues @sk_lingertime: %SO_LINGER l_linger setting @sk_backlog: always used with the per-socket spinlock held @sk_callback_lock: used with the callbacks in the end of this struct @sk_error_queue: rarely used @sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt, \t\t  IPV6_ADDRFORM for instance) @sk_err: last error @sk_err_soft: errors that don't cause failure but are the cause of a \t      persistent failure not just 'timed out' @sk_drops: raw/udp drops counter @sk_ack_backlog: current listen backlog @sk_max_ack_backlog: listen backlog set in listen() @sk_uid: user id of owner @sk_priority: %SO_PRIORITY setting @sk_type: socket type (%SOCK_STREAM, etc) @sk_protocol: which protocol this socket belongs in this network family @sk_peer_pid: &struct pid for this socket's peer @sk_peer_cred: %SO_PEERCRED setting @sk_rcvlowat: %SO_RCVLOWAT setting @sk_rcvtimeo: %SO_RCVTIMEO setting @sk_sndtimeo: %SO_SNDTIMEO setting @sk_txhash: computed flow hash for use on transmit @sk_filter: socket filtering instructions @sk_timer: sock cleanup timer @sk_stamp: time stamp of last packet received @sk_tsflags: SO_TIMESTAMPING socket options @sk_tskey: counter to disambiguate concurrent tstamp requests @sk_zckey: counter to order MSG_ZEROCOPY notifications @sk_socket: Identd and reporting IO signals @sk_user_data: RPC layer private data @sk_frag: cached page frag @sk_peek_off: current peek_offset value @sk_send_head: front of stuff to transmit @sk_security: used by security modules @sk_mark: generic packet mark @sk_cgrp_data: cgroup data for this cgroup @sk_memcg: this socket's memory cgroup association @sk_write_pending: a write to stream socket waits to start @sk_state_change: callback to indicate change in the state of the sock @sk_data_ready: callback to indicate there is data to be processed @sk_write_space: callback to indicate there is bf sending space available @sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE) @sk_backlog_rcv: callback to process the backlog @sk_destruct: called at sock freeing time, i.e. when all refcnt == 0 @sk_reuseport_cb: reuseport group container @sk_rcu: used during RCU grace period"],["sock__bindgen_ty_1",""],["sock_cgroup_data",""],["sock_cgroup_data__bindgen_ty_1__bindgen_ty_1",""],["sock_common","struct sock_common - minimal network layer representation of sockets @skc_daddr: Foreign IPv4 addr @skc_rcv_saddr: Bound local IPv4 addr @skc_hash: hash value used with various protocol lookup tables @skc_u16hashes: two u16 hash values used by UDP lookup tables @skc_dport: placeholder for inet_dport/tw_dport @skc_num: placeholder for inet_num/tw_num @skc_family: network address family @skc_state: Connection state @skc_reuse: %SO_REUSEADDR setting @skc_reuseport: %SO_REUSEPORT setting @skc_bound_dev_if: bound device index if != 0 @skc_bind_node: bind hash linkage for various protocol lookup tables @skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol @skc_prot: protocol handlers inside a network family @skc_net: reference to the network namespace of this socket @skc_node: main hash linkage for various protocol lookup tables @skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol @skc_tx_queue_mapping: tx queue number for this connection @skc_flags: place holder for sk_flags \t%SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE, \t%SO_OOBINLINE settings, %SO_TIMESTAMPING settings @skc_incoming_cpu: record/match cpu processing incoming packets @skc_refcnt: reference count"],["sock_common__bindgen_ty_1__bindgen_ty_1",""],["sock_common__bindgen_ty_3__bindgen_ty_1",""],["sock_filter",""],["sock_fprog_kern",""],["sock_reuseport",""],["sockaddr",""],["socket","struct socket - general BSD socket @state: socket state (%SS_CONNECTED, etc) @type: socket type (%SOCK_STREAM, etc) @flags: socket flags (%SOCK_NOSPACE, etc) @ops: protocol specific socket operations @file: File back pointer for gc @sk: internal networking protocol agnostic socket representation @wq: wait queue for several uses"],["socket_lock_t",""],["socket_wq",""],["spinlock",""],["static_key",""],["subsys_private",""],["super_block",""],["super_operations",""],["swap_info_struct",""],["swregs_state",""],["sync_serial_settings",""],["sysfs_ops",""],["sysv_sem",""],["sysv_shm",""],["task_cputime","struct task_cputime - collected CPU time counts @utime:\t\ttime spent in user mode, in nanoseconds @stime:\t\ttime spent in kernel mode, in nanoseconds @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"],["task_delay_info",""],["task_group",""],["task_io_accounting",""],["task_rss_stat",""],["task_struct",""],["tc_sizespec",""],["tc_stats",""],["tcf_block",""],["tcf_chain",""],["tcf_proto",""],["tcf_proto_ops",""],["tcf_result",""],["tcf_result__bindgen_ty_1__bindgen_ty_1",""],["tcf_walker",""],["tcmsg","Traffic control messages."],["tcp_congestion_ops",""],["tcp_fastopen_context",""],["tcp_mib",""],["tcphdr",""],["te1_settings",""],["thread_info",""],["thread_struct",""],["timer_list",""],["timerqueue_head",""],["timerqueue_node",""],["timespec",""],["timewait_sock_ops",""],["tlbflush_unmap_batch",""],["trace_eval_map",""],["trace_event_call",""],["tracepoint",""],["tracepoint_func",""],["u64_stats_sync",""],["ucounts",""],["udp_mib",""],["udp_table",""],["udp_tunnel_info",""],["udphdr",""],["uid_gid_extent",""],["uid_gid_map",""],["uid_gid_map__bindgen_ty_1__bindgen_ty_1",""],["upid",""],["uprobe",""],["uprobe_task",""],["uprobe_task__bindgen_ty_1__bindgen_ty_1",""],["uprobe_task__bindgen_ty_1__bindgen_ty_2",""],["uprobes_state",""],["user_namespace",""],["user_struct",""],["userfaultfd_ctx",""],["uts_namespace",""],["uuid_t",""],["vdso_image",""],["vfsmount",""],["vlan_info",""],["vm_area_struct",""],["vm_area_struct__bindgen_ty_1",""],["vm_fault",""],["vm_operations_struct",""],["vm_struct",""],["vm_userfaultfd_ctx",""],["vmacache",""],["vmem_altmap","struct vmem_altmap - pre-allocated storage for vmemmap_populate @base_pfn: base of the entire dev_pagemap mapping @reserve: pages mapped, but reserved for driver use (relative to @base) @free: free pages set aside in the mapping for memmap storage @align: pages reserved to meet allocation alignments @alloc: track pages consumed, private to vmemmap_populate()"],["vmpressure",""],["vtime",""],["wait_queue_head",""],["wake_irq",""],["wake_q_node",""],["wakeup_source","struct wakeup_source - Representation of wakeup sources"],["wb_domain",""],["wireless_dev",""],["work_struct",""],["workqueue_struct",""],["wpan_dev",""],["writeback_control",""],["xattr_handler",""],["xdp_buff",""],["xdp_md",""],["xdp_rxq_info","DOC: XDP RX-queue information"],["xfrm_policy",""],["xfrm_policy_hash",""],["xfrm_policy_hthresh",""],["xfrm_state",""],["xfrmdev_ops",""],["xol_area",""],["xps_dev_maps",""],["xps_map",""],["xregs_state",""],["xt_table",""],["zone",""],["zone_padding",""],["zone_reclaim_stat",""],["zonelist",""],["zoneref",""]],"type":[["Elf64_Addr",""],["Elf64_Half",""],["Elf64_Sym",""],["Elf64_Word",""],["Elf64_Xword",""],["__addrpair",""],["__be16",""],["__be32",""],["__be64",""],["__kernel_clock_t",""],["__kernel_clockid_t",""],["__kernel_dev_t",""],["__kernel_gid32_t",""],["__kernel_loff_t",""],["__kernel_long_t",""],["__kernel_pid_t",""],["__kernel_sa_family_t",""],["__kernel_size_t",""],["__kernel_ssize_t",""],["__kernel_time_t",""],["__kernel_timer_t",""],["__kernel_uid32_t",""],["__kernel_ulong_t",""],["__le16",""],["__poll_t",""],["__portpair",""],["__s16",""],["__s32",""],["__s64",""],["__s8",""],["__sum16",""],["__u16",""],["__u32",""],["__u64",""],["__u8",""],["__wsum",""],["_bindgen_ty_110",""],["_bindgen_ty_38",""],["_bindgen_ty_4",""],["_bindgen_ty_47",""],["_bindgen_ty_5",""],["_bindgen_ty_6",""],["arch_rwlock_t",""],["arch_spinlock_t",""],["atomic_long_t",""],["bio_end_io_t",""],["blk_status_t",""],["blkcnt_t",""],["bool_",""],["bpf_adj_room_mode",""],["bpf_attach_type",""],["bpf_aux_classic_check_t",""],["bpf_cmd",""],["bpf_func_id",""],["bpf_jit_fill_hole_t",""],["bpf_map_type",""],["bpf_netdev_command",""],["bpf_op_t",""],["bpf_prog_type",""],["bpf_ret_code",""],["clockid_t",""],["compat_long_t",""],["compat_time_t",""],["compat_uptr_t",""],["congested_fn",""],["cpumask_t",""],["cpumask_var_t",""],["dev_page_fault_t",""],["dev_page_free_t",""],["dev_t",""],["dl_dev_state","enum dl_dev_state - Device driver presence tracking information. @DL_DEV_NO_DRIVER: There is no driver attached to the device. @DL_DEV_PROBING: A driver is probing. @DL_DEV_DRIVER_BOUND: The driver has been bound to the device. @DL_DEV_UNBINDING: The driver is unbinding from the device."],["dma_addr_t",""],["dma_data_direction",""],["errseq_t",""],["ethtool_phys_id_state","enum ethtool_phys_id_state - indicator state for physical identification @ETHTOOL_ID_INACTIVE: Physical ID indicator should be deactivated @ETHTOOL_ID_ACTIVE: Physical ID indicator should be activated @ETHTOOL_ID_ON: LED should be turned on (used iff %ETHTOOL_ID_ACTIVE is not supported) @ETHTOOL_ID_OFF: LED should be turned off (used iff %ETHTOOL_ID_ACTIVE is not supported)"],["filldir_t",""],["fl_owner_t",""],["fmode_t",""],["gfp_t",""],["gid_t",""],["hrtimer_restart",""],["isolate_mode_t",""],["kernel_cap_t",""],["key_perm_t",""],["key_restrict_link_func_t",""],["key_serial_t",""],["kobj_ns_type",""],["ktime_t",""],["loff_t",""],["memcg_kmem_state",""],["memory_type",""],["mempool_alloc_t",""],["mempool_free_t",""],["mempool_t",""],["migrate_mode",""],["module_state",""],["net_device__bindgen_ty_2",""],["net_device__bindgen_ty_3",""],["netdev_features_t",""],["netdev_tx",""],["netdev_tx_t",""],["nf_bridge_info__bindgen_ty_1",""],["notifier_fn_t",""],["page_entry_size",""],["percpu_ref_func_t",""],["pgdval_t",""],["pgprot_t",""],["pgprotval_t",""],["pgtable_t",""],["phys_addr_t",""],["pid_t",""],["pid_type",""],["pm_message_t",""],["pmdval_t",""],["poll_queue_proc",""],["probe_type","enum probe_type - device driver probe type to try Device drivers may opt in for special handling of their respective probe routines. This tells the core what to expect and prefer."],["proc_handler",""],["projid_t",""],["pteval_t",""],["pudval_t",""],["qsize_t",""],["quota_type",""],["raw_spinlock_t",""],["rcu_sync_type",""],["refcount_t",""],["resource_size_t",""],["rpm_request",""],["rpm_status",""],["rw_hint",""],["rx_handler_func_t",""],["rx_handler_result",""],["rx_handler_result_t",""],["s16",""],["s32",""],["s64",""],["s8",""],["sa_family_t",""],["sector_t",""],["select_queue_fallback_t",""],["seqcount_t",""],["siginfo_t",""],["sigval_t",""],["sk_action",""],["sk_buff_data_t",""],["sk_pacing",""],["sk_read_actor_t",""],["slab_flags_t",""],["socket_state",""],["spinlock_t",""],["tc_setup_type",""],["time64_t",""],["timespec_type",""],["u16",""],["u32",""],["u64",""],["u8",""],["uid_t",""],["umode_t",""],["uprobe_task_state",""],["vtime_state",""],["wait_queue_head_t",""],["wb_reason",""],["work_func_t",""],["writeback_sync_modes",""],["xdp_action",""],["zone_type",""]],"union":[["bdi_writeback__bindgen_ty_1",""],["bio__bindgen_ty_1",""],["bpf_attr",""],["bpf_attr__bindgen_ty_2__bindgen_ty_1",""],["bpf_attr__bindgen_ty_7__bindgen_ty_1",""],["bpf_sock_ops__bindgen_ty_1",""],["bpf_sock_ops_kern__bindgen_ty_1",""],["bpf_tunnel_key__bindgen_ty_1",""],["ctl_table_header__bindgen_ty_1",""],["dentry__bindgen_ty_1",""],["dentry__bindgen_ty_2",""],["ethtool_flow_union",""],["file__bindgen_ty_1",""],["file_lock__bindgen_ty_1",""],["flowi__bindgen_ty_1",""],["flowi_uli",""],["fxregs_state__bindgen_ty_1",""],["fxregs_state__bindgen_ty_2",""],["if_settings__bindgen_ty_1",""],["ifreq__bindgen_ty_1",""],["ifreq__bindgen_ty_2",""],["in6_addr__bindgen_ty_1",""],["inode__bindgen_ty_1",""],["inode__bindgen_ty_2",""],["inode__bindgen_ty_3",""],["io_cq__bindgen_ty_1",""],["io_cq__bindgen_ty_2",""],["iov_iter__bindgen_ty_1",""],["iov_iter__bindgen_ty_2",""],["kernel_param__bindgen_ty_1",""],["kernfs_node__bindgen_ty_1",""],["kernfs_node_id",""],["key__bindgen_ty_1",""],["key__bindgen_ty_2",""],["key__bindgen_ty_3",""],["key__bindgen_ty_4",""],["key_payload",""],["kqid__bindgen_ty_1",""],["lockref__bindgen_ty_1",""],["net_device__bindgen_ty_4",""],["netdev_bpf__bindgen_ty_1",""],["nf_bridge_info__bindgen_ty_2",""],["page__bindgen_ty_1",""],["page__bindgen_ty_2",""],["page__bindgen_ty_3",""],["page__bindgen_ty_4",""],["page__bindgen_ty_5",""],["proto__bindgen_ty_1",""],["qrwlock__bindgen_ty_1",""],["qstr__bindgen_ty_1",""],["radix_tree_node__bindgen_ty_1",""],["read_descriptor_t__bindgen_ty_1",""],["restart_block__bindgen_ty_1",""],["restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1",""],["siginfo__bindgen_ty_1",""],["siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1",""],["sigval",""],["sk_buff__bindgen_ty_1",""],["sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1",""],["sk_buff__bindgen_ty_2",""],["sk_buff__bindgen_ty_3",""],["sk_buff__bindgen_ty_4",""],["sk_buff__bindgen_ty_5",""],["sk_buff__bindgen_ty_6",""],["sk_buff__bindgen_ty_7",""],["sock__bindgen_ty_2",""],["sock__bindgen_ty_3",""],["sock_cgroup_data__bindgen_ty_1",""],["sock_common__bindgen_ty_1",""],["sock_common__bindgen_ty_2",""],["sock_common__bindgen_ty_3",""],["sock_common__bindgen_ty_4",""],["sock_common__bindgen_ty_5",""],["sock_common__bindgen_ty_6",""],["sock_common__bindgen_ty_7",""],["sock_common__bindgen_ty_8",""],["spinlock__bindgen_ty_1",""],["tcf_result__bindgen_ty_1",""],["uid_gid_map__bindgen_ty_1",""],["uprobe_task__bindgen_ty_1",""]]});